add_layer {P P.red P.green P.blue P.X P.Y P.Z P.alpha}
add_layer {N N.red N.green N.blue}
Group {
 name SSAO
 selected true
 addUserKnob {20 User l SSAO}
 addUserKnob {41 in l "worldSpace Position" T ViewSpaceP.in}
 addUserKnob {41 in_1 l "worldSpace Normal" T ViewSpaceN.in}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {7 radius l Radius}
 radius 1
 addUserKnob {26 ""}
 addUserKnob {7 falloff l Falloff}
 falloff 0.5
 addUserKnob {7 intensity l Intensity R 0 5}
 intensity 3
 addUserKnob {7 soften l "Soften above"}
 soften 0.5
 addUserKnob {7 maxocc l Maximum}
 maxocc 0.7
 addUserKnob {26 ""}
 addUserKnob {3 samples l Samples}
 samples 4096
 addUserKnob {3 seed l Seed -STARTLINE}
 addUserKnob {6 randomize +STARTLINE}
 randomize true
 addUserKnob {7 threshold l "error threshold" R 1e-05 0.1}
 threshold 0.025
}
 Radial {
  inputs 0
  area {480 270 1440 810}
  name Radial1
  xpos 1039
  ypos -17
 }
 Expression {
  channel0 rgba
  expr0 random(x)
  name Expression3
  xpos 1039
  ypos 38
 }
 Constant {
  inputs 0
  channels rgb
  name Constant3
  xpos 800
  ypos 87
 }
 Reformat {
  type "to box"
  box_width {{BlinkScript2.SSAO_rotations}}
  box_height {{BlinkScript2.SSAO_rotations}}
  box_fixed true
  resize none
  center false
  name Reformat2
  xpos 800
  ypos 159
 }
 Expression {
  expr0 random(x+(y*height)+(parent.seed*width*height))
  expr1 random((parent.seed*height*width)+(width*height)+y+(x*width))
  expr2 0
  name Expression1
  label "Random\nTangent\nRotations"
  xpos 800
  ypos 185
 }
 Grade {
  channels {rgba.red rgba.green -rgba.blue none}
  multiply 2
  add -1
  black_clamp false
  name Grade1
  xpos 800
  ypos 254
 }
 Expression {
  expr0 0.1
  expr1 0.2
  expr2 0
  name Expression4
  label "Constant\ntangent"
  xpos 800
  ypos 304
  disable {{parent.randomize}}
 }
 Dot {
  name Dot6
  xpos 834
  ypos 461
 }
 Dot {
  name Dot4
  xpos 378
  ypos 461
 }
 Constant {
  inputs 0
  channels rgb
  name Constant2
  xpos 387
  ypos 66
 }
 Reformat {
  type "to box"
  box_width {{BlinkScript2.SSAO_samples}}
  box_height 1
  box_fixed true
  resize none
  name Reformat1
  xpos 387
  ypos 138
 }
set N92c8cad0 [stack 0]
 Dot {
  name Dot10
  xpos 550
  ypos 142
 }
 Expression {
  channel0 rgba
  expr0 (x)/width
  name Expression2
  xpos 516
  ypos 176
 }
 Gamma {
  channels rgba
  value {{parent.falloff}}
  name Gamma1
  xpos 516
  ypos 228
 }
 Grade {
  black {{parent.threshold}}
  name Grade2
  xpos 516
  ypos 254
 }
 Dot {
  name Dot9
  xpos 550
  ypos 295
 }
push $N92c8cad0
 Expression {
  expr0 (random(x+(parent.seed*width))*2)-1
  expr1 (random(width+x+(parent.seed*width))*2)-1
  expr2 random((2*width)+x+(parent.seed*width))
  name Expression5
  label "Hemisphere\nSamples"
  selected true
  xpos 387
  ypos 176
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos 387
  ypos 291
 }
 Dot {
  name Dot5
  xpos 421
  ypos 361
 }
 Input {
  inputs 0
  name Camera
  xpos -275
  ypos -41
  number 1
 }
 Dot {
  name Dot1
  xpos -241
  ypos 42
 }
set N7b917530 [stack 0]
 Dot {
  name Dot2
  xpos -241
  ypos 85
 }
push $N7b917530
 Input {
  inputs 0
  name Input
  xpos 0
  ypos -57
 }
 Group {
  inputs 2
  name ViewSpaceP
  label Position
  xpos 0
  ypos 32
  addUserKnob {20 User l ScreenSpaceTransform}
  addUserKnob {41 in l Vector T vectorIn.in}
  addUserKnob {6 project +STARTLINE}
  addUserKnob {6 isNormal +STARTLINE}
  addUserKnob {6 invert +STARTLINE}
 }
  Input {
   inputs 0
   name Camera
   xpos 752
   ypos -52
   number 1
  }
  Input {
   inputs 0
   name Vector
   xpos 220
   ypos -48
  }
  Dot {
   name Dot1
   xpos 254
   ypos 1
  }
set N5383d280 [stack 0]
  Dot {
   name Dot2
   xpos 403
   ypos 1
  }
  Shuffle {
   in P
   name vectorIn
   xpos 369
   ypos 51
  }
  BlinkScript {
   recompileCount 268
   ProgramGroup 1
   KernelDescription "2 \"SaturationKernel\" iterate pixelWise 3a50bfff32b58b54a88217da56a4dae927eec9541acd2fe5c5c9b015f01db8be 2 \"Vector\" Read Point \"dst\" Write Point 10 \"focalLength\" Float 1 AAAAAA== \"hape\" Float 1 AAAAAA== \"width\" Int 1 AAAAAA== \"height\" Int 1 AAAAAA== \"Near\" Float 1 zczMPQ== \"Far\" Float 1 AEAcRg== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"project\" Int 1 AAAAAA== \"invert\" Int 1 AAAAAA== \"isNormal\" Int 1 AAAAAA== 10 \"focalLength\" 1 1 \"hape\" 1 1 \"width\" 1 1 \"height\" 1 1 \"near\" 1 1 \"far\" 1 1 \"transform\" 16 1 \"project\" 1 1 \"invert\" 1 1 \"isNormal\" 1 1 5 \"aov\" Float 1 1 AAAAAA== \"transformInverted\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraProjection\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"aspect\" Float 1 1 AAAAAA== \"transformNormal\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
   kernelSource "#define PI 3.1415926535897932384626433832795028841971693993751058;\n\nfloat3 norm(float3 a)\{\n  return a/length(a);\n\}\n\nfloat4x4 ident4x4()\{\n  float4x4 mat;\n  mat\[0]\[0] = 1.0;\n  mat\[0]\[1] = 0.0;\n  mat\[0]\[2] = 0.0;\n  mat\[0]\[3] = 0.0;\n  mat\[1]\[0] = 0.0;\n  mat\[1]\[1] = 1.0;\n  mat\[1]\[2] = 0.0;\n  mat\[1]\[3] = 0.0;\n  mat\[2]\[0] = 0.0;\n  mat\[2]\[1] = 0.0;\n  mat\[2]\[2] = 1.0;\n  mat\[2]\[3] = 0.0;\n  mat\[3]\[0] = 0.0;\n  mat\[3]\[1] = 0.0;\n  mat\[3]\[2] = 0.0;\n  mat\[3]\[3] = 1.0;\n  return mat;\n\}\n\nfloat4x4 rotateAxis(float angle, int axis)\{\n  float4x4 mat = ident4x4();\n  if(axis==0)\{      // X\n    mat\[1]\[1] =  cos(angle);\n    mat\[1]\[2] = -sin(angle);\n    mat\[2]\[1] =  sin(angle);\n    mat\[2]\[2] =  cos(angle);\n  \}else if(axis==1)\{// Y\n    mat\[0]\[0] =  cos(angle);\n    mat\[0]\[2] =  sin(angle);\n    mat\[2]\[0] = -sin(angle);\n    mat\[2]\[2] =  cos(angle);\n  \}else if(axis==2)\{// Z\n    mat\[0]\[0] =  cos(angle);\n    mat\[0]\[1] = -sin(angle);\n    mat\[1]\[0] =  sin(angle);\n    mat\[1]\[1] =  cos(angle);\n  \}\n  return mat;\n\}\n\nfloat3 mult(float3 a, float4x4 mat)\{\n  return float3((a.x*mat\[0]\[0])+(a.y*mat\[0]\[1])+(a.z*mat\[0]\[2])+mat\[0]\[3],\n                (a.x*mat\[1]\[0])+(a.y*mat\[1]\[1])+(a.z*mat\[1]\[2])+mat\[1]\[3],\n                (a.x*mat\[2]\[0])+(a.y*mat\[2]\[1])+(a.z*mat\[2]\[2])+mat\[2]\[3]);\n\}\n\nfloat3 multPointMatrix(float3 in,  float4x4 M) \n\{ \n    float3 out = float3(0,0,0);\n    out.x   = in.x * M\[0]\[0] + in.y * M\[0]\[1] + in.z * M\[0]\[2] + M\[0]\[3]; \n    out.y   = in.x * M\[1]\[0] + in.y * M\[1]\[1] + in.z * M\[1]\[2] + M\[1]\[3]; \n    out.z   = in.x * M\[2]\[0] + in.y * M\[2]\[1] + in.z * M\[2]\[2] + M\[2]\[3]; \n    float w = in.x * M\[3]\[0] + in.y * M\[3]\[1] + in.z * M\[3]\[2] + M\[3]\[3]; \n \n    // normalize if w is different than 1 (convert from homogeneous to Cartesian coordinates)\n    if (w != 1) \{ \n        out.x /= w; \n        out.y /= w; \n        //out.z /= w; \n    \}\n    return out;\n\}\nfloat3 divPointMatrix(float3 in,  float4x4 M) \n\{ \n    float w = in.x * M\[3]\[0] + in.y * M\[3]\[1] + in.z * M\[3]\[2] + M\[3]\[3];;\n    // normalize if w is different than 1 (convert from homogeneous to Cartesian coordinates)\n    if (w != 1) \{ \n        in.x *= w; \n        in.y *= w; \n        //out.z /= w; \n    \}\n    float3 out = float3(0,0,0);\n    out.x   = in.x / M\[0]\[0]; \n    out.y   = in.y / M\[1]\[1]; \n    out.z   = in.z / M\[2]\[2]; \n\n \n    return out;\n\}\n\nfloat4x4 projectionMatrix(float aov, float aspect, float near, float far)\{\n  float4x4 M = ident4x4();\n  // X\n  M\[0]\[0] = 1.0f / (aspect * tan(aov / 2.0f)); // scale the x coordinates of the projected point \n  M\[0]\[1] = 0.0;\n  M\[0]\[2] = 0.0;\n  M\[0]\[3] = 0.0;\n  // Y\n  M\[1]\[0] = 0.0;\n  M\[1]\[1] = 1.0f / tan(aov / 2.0f); // scale the y coordinates of the projected point \n  M\[1]\[2] = 0.0;\n  M\[1]\[3] = 0.0;\n  // Z\n  M\[2]\[0] = 0.0;\n  M\[2]\[1] = 0.0;\n  //M\[2]\[2] = far / (far - near);\n  //M\[2]\[3] = -far * near / (far - near);\n  // Offset\n  M\[3]\[0] = 0.0;\n  M\[3]\[1] = 0.0;\n  M\[3]\[2] = -1.0;\n  M\[3]\[3] = 0.0;\n  return M;\n\}\n\n\nfloat angleOfView(float aperture, float focalLength)\{\n  return 2.0f * atan( 0.5f * aperture / focalLength);\n\}\n\n\n\nkernel SaturationKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> Vector; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    float focalLength;\n    float hape;\n    int width;\n    int height;\n    float near;\n    float far;\n    float4x4 transform;\n    int project;\n    int invert;\n    int isNormal;\n\n  local:\n    float aov;\n    float4x4 transformInverted;\n    float4x4 cameraProjection;\n    float aspect;\n    float4x4 transformNormal;\n\n  void define() \{\n    defineParam(near, \"Near\", 0.1f);\n    defineParam(far, \"Far\", 10000.0f);\n  \}\n\n  void init() \{\n    aspect = float(width) / float(height);\n    aov = angleOfView(hape, focalLength * aspect);\n\n    cameraProjection = projectionMatrix(aov, aspect, near, far);\n\n    transformInverted = transform.invert();\n    transformNormal = transform;\n    if( isNormal == 1 )\{\n      transformInverted\[0]\[3] = 0.0f;\n      transformInverted\[1]\[3] = 0.0f;\n      transformInverted\[2]\[3] = 0.0f;\n      transformNormal\[0]\[3] = 0.0;\n      transformNormal\[1]\[3] = 0.0f;\n      transformNormal\[2]\[3] = 0.0f;\n    \}\n\n  \}\n\n\n\n  void process(int2 pos) \{\n    // Read the input image\n    SampleType(Vector) input  = Vector();\n    float3 v = float3(input\[0], input\[1], input\[2]);\n\n    float screenOffsetX = float(pos.x) / float(width);\n    screenOffsetX = (screenOffsetX * 2.0f) - 1.0f;\n    float screenOffsetY = float(pos.y) / float(height);\n    screenOffsetY = (screenOffsetY * 2.0f) - 1.0f;\n\n    if(invert == 0)\{\n      v = mult(v, transformInverted);\n      if( project == 1 )\{\n        if( isNormal == 1 )\{\n          float4x4 rotY = rotateAxis( aov * screenOffsetX * 0.5f * aspect, 1 );\n          float4x4 rotX = rotateAxis( aov * -screenOffsetY * 0.5f, 0 );\n          v = mult(v, rotY);\n          v = mult(v, rotX);\n        \}else\{\n          v = multPointMatrix(v, cameraProjection);\n        \}\n      \}\n    \}else\{\n      if( project == 1 )\{\n        if( isNormal == 1 )\{\n          float4x4 rotY = rotateAxis( aov * -screenOffsetX * 0.5f * aspect, 1 );\n          float4x4 rotX = rotateAxis( aov * screenOffsetY * 0.5f, 0 );\n          v = mult(v, rotX);\n          v = mult(v, rotY);\n        \}else\{\n          v = divPointMatrix(v, cameraProjection);\n        \}\n      \}\n      v = mult(v, transformNormal);\n    \}\n    if( isNormal == 1 )\{\n      v = norm(v);\n    \}\n    dst() = float4(v\[0], v\[1], v\[2], 0.0f);\n  \}\n\};\n"
   rebuild ""
   SaturationKernel_focalLength {{Camera1.focal}}
   SaturationKernel_hape {{Camera1.haperture}}
   SaturationKernel_width {{width}}
   SaturationKernel_height {{height}}
   SaturationKernel_Near {{Camera1.near}}
   SaturationKernel_Far {{Camera1.far}}
   group_SaturationKernel_transform 1
   SaturationKernel_transform {
       {{Camera1.world_matrix.0} {Camera1.world_matrix.1} {Camera1.world_matrix.2} {Camera1.world_matrix.3}}
       {{Camera1.world_matrix.4} {Camera1.world_matrix.5} {Camera1.world_matrix.6} {Camera1.world_matrix.7}}
       {{Camera1.world_matrix.8} {Camera1.world_matrix.9} {Camera1.world_matrix.10} {Camera1.world_matrix.11}}
       {{Camera1.world_matrix.12} {Camera1.world_matrix.13} {Camera1.world_matrix.14} {Camera1.world_matrix.15}}
     }
   SaturationKernel_project {{parent.project}}
   SaturationKernel_invert {{parent.invert}}
   SaturationKernel_isNormal {{parent.isNormal}}
   rebuild_finalise ""
   name BlinkScript4
   xpos 369
   ypos 154
  }
  Dot {
   name Dot3
   xpos 403
   ypos 274
  }
push $N5383d280
  ShuffleCopy {
   inputs 2
   in2 {{{vectorIn.in}}}
   red red
   green green
   blue blue
   alpha alpha2
   out {{{vectorIn.in}}}
   name ShuffleCopy1
   xpos 220
   ypos 270
  }
  Output {
   name Output1
   xpos 220
   ypos 313
  }
  Camera2 {
   inputs 0
   useMatrix true
   matrix {
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
     }
   focal {{"\[topnode parent.parent.input1].focal"}}
   haperture {{"\[topnode parent.parent.input1].haperture"}}
   near {{"\[topnode parent.parent.input1].near"}}
   far {{"\[topnode parent.parent.input1].far"}}
   name Camera1
   selected true
   xpos 762
   ypos 5
  }
 end_group
 Group {
  inputs 2
  name ViewSpaceN
  label Normal
  xpos 0
  ypos 75
  addUserKnob {20 User l ScreenSpaceTransform}
  addUserKnob {41 in l Vector T vectorIn.in}
  addUserKnob {6 project +STARTLINE}
  addUserKnob {6 isNormal +STARTLINE}
  isNormal true
  addUserKnob {6 invert +STARTLINE}
 }
  Input {
   inputs 0
   name Camera
   xpos 752
   ypos -52
   number 1
  }
  Input {
   inputs 0
   name Vector
   xpos 220
   ypos -48
  }
  Dot {
   name Dot1
   xpos 254
   ypos 1
  }
set Nf3fe1060 [stack 0]
  Dot {
   name Dot2
   xpos 403
   ypos 1
  }
  Shuffle {
   in N
   name vectorIn
   xpos 369
   ypos 51
  }
  BlinkScript {
   recompileCount 268
   ProgramGroup 1
   KernelDescription "2 \"SaturationKernel\" iterate pixelWise 3a50bfff32b58b54a88217da56a4dae927eec9541acd2fe5c5c9b015f01db8be 2 \"Vector\" Read Point \"dst\" Write Point 10 \"focalLength\" Float 1 AAAAAA== \"hape\" Float 1 AAAAAA== \"width\" Int 1 AAAAAA== \"height\" Int 1 AAAAAA== \"Near\" Float 1 zczMPQ== \"Far\" Float 1 AEAcRg== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"project\" Int 1 AAAAAA== \"invert\" Int 1 AAAAAA== \"isNormal\" Int 1 AAAAAA== 10 \"focalLength\" 1 1 \"hape\" 1 1 \"width\" 1 1 \"height\" 1 1 \"near\" 1 1 \"far\" 1 1 \"transform\" 16 1 \"project\" 1 1 \"invert\" 1 1 \"isNormal\" 1 1 5 \"aov\" Float 1 1 AAAAAA== \"transformInverted\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraProjection\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"aspect\" Float 1 1 AAAAAA== \"transformNormal\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
   kernelSource "#define PI 3.1415926535897932384626433832795028841971693993751058;\n\nfloat3 norm(float3 a)\{\n  return a/length(a);\n\}\n\nfloat4x4 ident4x4()\{\n  float4x4 mat;\n  mat\[0]\[0] = 1.0;\n  mat\[0]\[1] = 0.0;\n  mat\[0]\[2] = 0.0;\n  mat\[0]\[3] = 0.0;\n  mat\[1]\[0] = 0.0;\n  mat\[1]\[1] = 1.0;\n  mat\[1]\[2] = 0.0;\n  mat\[1]\[3] = 0.0;\n  mat\[2]\[0] = 0.0;\n  mat\[2]\[1] = 0.0;\n  mat\[2]\[2] = 1.0;\n  mat\[2]\[3] = 0.0;\n  mat\[3]\[0] = 0.0;\n  mat\[3]\[1] = 0.0;\n  mat\[3]\[2] = 0.0;\n  mat\[3]\[3] = 1.0;\n  return mat;\n\}\n\nfloat4x4 rotateAxis(float angle, int axis)\{\n  float4x4 mat = ident4x4();\n  if(axis==0)\{      // X\n    mat\[1]\[1] =  cos(angle);\n    mat\[1]\[2] = -sin(angle);\n    mat\[2]\[1] =  sin(angle);\n    mat\[2]\[2] =  cos(angle);\n  \}else if(axis==1)\{// Y\n    mat\[0]\[0] =  cos(angle);\n    mat\[0]\[2] =  sin(angle);\n    mat\[2]\[0] = -sin(angle);\n    mat\[2]\[2] =  cos(angle);\n  \}else if(axis==2)\{// Z\n    mat\[0]\[0] =  cos(angle);\n    mat\[0]\[1] = -sin(angle);\n    mat\[1]\[0] =  sin(angle);\n    mat\[1]\[1] =  cos(angle);\n  \}\n  return mat;\n\}\n\nfloat3 mult(float3 a, float4x4 mat)\{\n  return float3((a.x*mat\[0]\[0])+(a.y*mat\[0]\[1])+(a.z*mat\[0]\[2])+mat\[0]\[3],\n                (a.x*mat\[1]\[0])+(a.y*mat\[1]\[1])+(a.z*mat\[1]\[2])+mat\[1]\[3],\n                (a.x*mat\[2]\[0])+(a.y*mat\[2]\[1])+(a.z*mat\[2]\[2])+mat\[2]\[3]);\n\}\n\nfloat3 multPointMatrix(float3 in,  float4x4 M) \n\{ \n    float3 out = float3(0,0,0);\n    out.x   = in.x * M\[0]\[0] + in.y * M\[0]\[1] + in.z * M\[0]\[2] + M\[0]\[3]; \n    out.y   = in.x * M\[1]\[0] + in.y * M\[1]\[1] + in.z * M\[1]\[2] + M\[1]\[3]; \n    out.z   = in.x * M\[2]\[0] + in.y * M\[2]\[1] + in.z * M\[2]\[2] + M\[2]\[3]; \n    float w = in.x * M\[3]\[0] + in.y * M\[3]\[1] + in.z * M\[3]\[2] + M\[3]\[3]; \n \n    // normalize if w is different than 1 (convert from homogeneous to Cartesian coordinates)\n    if (w != 1) \{ \n        out.x /= w; \n        out.y /= w; \n        //out.z /= w; \n    \}\n    return out;\n\}\nfloat3 divPointMatrix(float3 in,  float4x4 M) \n\{ \n    float w = in.x * M\[3]\[0] + in.y * M\[3]\[1] + in.z * M\[3]\[2] + M\[3]\[3];;\n    // normalize if w is different than 1 (convert from homogeneous to Cartesian coordinates)\n    if (w != 1) \{ \n        in.x *= w; \n        in.y *= w; \n        //out.z /= w; \n    \}\n    float3 out = float3(0,0,0);\n    out.x   = in.x / M\[0]\[0]; \n    out.y   = in.y / M\[1]\[1]; \n    out.z   = in.z / M\[2]\[2]; \n\n \n    return out;\n\}\n\nfloat4x4 projectionMatrix(float aov, float aspect, float near, float far)\{\n  float4x4 M = ident4x4();\n  // X\n  M\[0]\[0] = 1.0f / (aspect * tan(aov / 2.0f)); // scale the x coordinates of the projected point \n  M\[0]\[1] = 0.0;\n  M\[0]\[2] = 0.0;\n  M\[0]\[3] = 0.0;\n  // Y\n  M\[1]\[0] = 0.0;\n  M\[1]\[1] = 1.0f / tan(aov / 2.0f); // scale the y coordinates of the projected point \n  M\[1]\[2] = 0.0;\n  M\[1]\[3] = 0.0;\n  // Z\n  M\[2]\[0] = 0.0;\n  M\[2]\[1] = 0.0;\n  //M\[2]\[2] = far / (far - near);\n  //M\[2]\[3] = -far * near / (far - near);\n  // Offset\n  M\[3]\[0] = 0.0;\n  M\[3]\[1] = 0.0;\n  M\[3]\[2] = -1.0;\n  M\[3]\[3] = 0.0;\n  return M;\n\}\n\n\nfloat angleOfView(float aperture, float focalLength)\{\n  return 2.0f * atan( 0.5f * aperture / focalLength);\n\}\n\n\n\nkernel SaturationKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> Vector; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    float focalLength;\n    float hape;\n    int width;\n    int height;\n    float near;\n    float far;\n    float4x4 transform;\n    int project;\n    int invert;\n    int isNormal;\n\n  local:\n    float aov;\n    float4x4 transformInverted;\n    float4x4 cameraProjection;\n    float aspect;\n    float4x4 transformNormal;\n\n  void define() \{\n    defineParam(near, \"Near\", 0.1f);\n    defineParam(far, \"Far\", 10000.0f);\n  \}\n\n  void init() \{\n    aspect = float(width) / float(height);\n    aov = angleOfView(hape, focalLength * aspect);\n\n    cameraProjection = projectionMatrix(aov, aspect, near, far);\n\n    transformInverted = transform.invert();\n    transformNormal = transform;\n    if( isNormal == 1 )\{\n      transformInverted\[0]\[3] = 0.0f;\n      transformInverted\[1]\[3] = 0.0f;\n      transformInverted\[2]\[3] = 0.0f;\n      transformNormal\[0]\[3] = 0.0;\n      transformNormal\[1]\[3] = 0.0f;\n      transformNormal\[2]\[3] = 0.0f;\n    \}\n\n  \}\n\n\n\n  void process(int2 pos) \{\n    // Read the input image\n    SampleType(Vector) input  = Vector();\n    float3 v = float3(input\[0], input\[1], input\[2]);\n\n    float screenOffsetX = float(pos.x) / float(width);\n    screenOffsetX = (screenOffsetX * 2.0f) - 1.0f;\n    float screenOffsetY = float(pos.y) / float(height);\n    screenOffsetY = (screenOffsetY * 2.0f) - 1.0f;\n\n    if(invert == 0)\{\n      v = mult(v, transformInverted);\n      if( project == 1 )\{\n        if( isNormal == 1 )\{\n          float4x4 rotY = rotateAxis( aov * screenOffsetX * 0.5f * aspect, 1 );\n          float4x4 rotX = rotateAxis( aov * -screenOffsetY * 0.5f, 0 );\n          v = mult(v, rotY);\n          v = mult(v, rotX);\n        \}else\{\n          v = multPointMatrix(v, cameraProjection);\n        \}\n      \}\n    \}else\{\n      if( project == 1 )\{\n        if( isNormal == 1 )\{\n          float4x4 rotY = rotateAxis( aov * -screenOffsetX * 0.5f * aspect, 1 );\n          float4x4 rotX = rotateAxis( aov * screenOffsetY * 0.5f, 0 );\n          v = mult(v, rotX);\n          v = mult(v, rotY);\n        \}else\{\n          v = divPointMatrix(v, cameraProjection);\n        \}\n      \}\n      v = mult(v, transformNormal);\n    \}\n    if( isNormal == 1 )\{\n      v = norm(v);\n    \}\n    dst() = float4(v\[0], v\[1], v\[2], 0.0f);\n  \}\n\};\n"
   rebuild ""
   SaturationKernel_focalLength {{Camera1.focal}}
   SaturationKernel_hape {{Camera1.haperture}}
   SaturationKernel_width {{width}}
   SaturationKernel_height {{height}}
   SaturationKernel_Near {{Camera1.near}}
   SaturationKernel_Far {{Camera1.far}}
   group_SaturationKernel_transform 1
   SaturationKernel_transform {
       {{Camera1.world_matrix.0} {Camera1.world_matrix.1} {Camera1.world_matrix.2} {Camera1.world_matrix.3}}
       {{Camera1.world_matrix.4} {Camera1.world_matrix.5} {Camera1.world_matrix.6} {Camera1.world_matrix.7}}
       {{Camera1.world_matrix.8} {Camera1.world_matrix.9} {Camera1.world_matrix.10} {Camera1.world_matrix.11}}
       {{Camera1.world_matrix.12} {Camera1.world_matrix.13} {Camera1.world_matrix.14} {Camera1.world_matrix.15}}
     }
   SaturationKernel_project {{parent.project}}
   SaturationKernel_invert {{parent.invert}}
   SaturationKernel_isNormal {{parent.isNormal}}
   rebuild_finalise ""
   name BlinkScript4
   xpos 369
   ypos 154
  }
  Dot {
   name Dot3
   xpos 403
   ypos 274
  }
push $Nf3fe1060
  ShuffleCopy {
   inputs 2
   in2 {{{vectorIn.in}}}
   red red
   green green
   blue blue
   alpha alpha2
   out {{{vectorIn.in}}}
   name ShuffleCopy1
   xpos 220
   ypos 270
  }
  Output {
   name Output1
   xpos 220
   ypos 313
  }
  Camera2 {
   inputs 0
   useMatrix true
   matrix {
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
     }
   focal {{"\[topnode parent.parent.input1].focal"}}
   haperture {{"\[topnode parent.parent.input1].haperture"}}
   near {{"\[topnode parent.parent.input1].near"}}
   far {{"\[topnode parent.parent.input1].far"}}
   name Camera1
   selected true
   xpos 762
   ypos 5
  }
 end_group
 Dot {
  name Dot7
  xpos 34
  ypos 164
 }
set N3964d540 [stack 0]
 Dot {
  name Dot8
  xpos -112
  ypos 164
 }
 Shuffle {
  in {{{ViewSpaceN.vectorIn.in}}}
  name Shuffle1
  label "ViewSpace\nNormal"
  xpos -146
  ypos 200
  postage_stamp true
 }
 Dot {
  name Dot3
  xpos -112
  ypos 361
 }
push $N3964d540
 Shuffle {
  in {{{ViewSpaceP.vectorIn.in}}}
  name Shuffle2
  label "ViewSpace\nPosition"
  xpos 0
  ypos 200
  postage_stamp true
 }
 BlinkScript {
  inputs 4
  recompileCount 153
  ProgramGroup 1
  KernelDescription "2 \"SSAO\" iterate pixelWise 71cf8b2d287a5f9d8163000924656f6579195e7b35333ae2ca801b33f36984a0 5 \"inViewSpaceP\" Read Random \"inViewSpaceN\" Read Point \"inSamples\" Read Random \"inRandRots\" Read Random \"dst\" Write Point 8 \"samples\" Int 1 AAAAAA== \"rotations\" Int 1 AAAAAA== \"radius\" Float 1 AAAAAA== \"bias\" Float 1 AAAAAA== \"width\" Int 1 AAAAAA== \"height\" Int 1 AAAAAA== \"focal\" Float 1 AAAAAA== \"haperture\" Float 1 AAAAAA== 8 \"samples\" 1 1 \"rotations\" 1 1 \"radius\" 1 1 \"bias\" 1 1 \"width\" 1 1 \"height\" 1 1 \"focal\" 1 1 \"haperture\" 1 1 2 \"aspect\" Float 1 1 AAAAAA== \"projection\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "// 2021-08-25\n// Made by Mathieu Goulet-Aubin\n// email: mathieugouletaubin@gmail.com\n// Based on OpenGL SSAO lesson https://learnopengl.com/Advanced-Lighting/SSAO\n\nfloat4 color(float3 vector)\{\n    return float4(vector.x, vector.y, vector.z, 0);\n\}\nfloat4 color(float3 vector, float a)\{\n    return float4(vector.x, vector.y, vector.z, a);\n\}\nfloat3 vector(float4 color)\{\n    return float3(color.x, color.y, color.z);\n\}\nfloat3 norm(float3 a)\{\n  return a/length(a);\n\}\nfloat smoothstep(float edge0, float edge1, float x) \{\n  // Scale, bias and saturate x to 0..1 range\n  x = clamp((x - edge0) / (edge1 - edge0), 0.0f, 1.0f); \n  // Evaluate polynomial\n  return x * x * (3 - 2 * x);\n\}\nfloat4x4 matrix4x4(float3 tangent, float3 bitangent, float3 normal)\{\n  // Creates a matrix from frame vectors\n  float4x4 mat;\n  mat\[0]\[0] = tangent.x;\n  mat\[0]\[1] = tangent.y;\n  mat\[0]\[2] = tangent.z;\n  mat\[0]\[3] = 0.0;\n  mat\[1]\[0] = bitangent.x;\n  mat\[1]\[1] = bitangent.y;\n  mat\[1]\[2] = bitangent.z;\n  mat\[1]\[3] = 0.0;\n  mat\[2]\[0] = normal.x;\n  mat\[2]\[1] = normal.y;\n  mat\[2]\[2] = normal.z;\n  mat\[2]\[3] = 0.0;\n  mat\[3]\[0] = 0.0;\n  mat\[3]\[1] = 0.0;\n  mat\[3]\[2] = 0.0;\n  mat\[3]\[3] = 1.0;\n  return mat.invert();\n\}\nfloat3 mult(float3 a, float4x4 mat)\{\n  return float3((a.x*mat\[0]\[0])+(a.y*mat\[0]\[1])+(a.z*mat\[0]\[2])+mat\[0]\[3],\n                (a.x*mat\[1]\[0])+(a.y*mat\[1]\[1])+(a.z*mat\[1]\[2])+mat\[1]\[3],\n                (a.x*mat\[2]\[0])+(a.y*mat\[2]\[1])+(a.z*mat\[2]\[2])+mat\[2]\[3]);\n\}\nfloat4 mult(float4 a, float4x4 mat)\{\n  return float4((a.x*mat\[0]\[0])+(a.y*mat\[0]\[1])+(a.z*mat\[0]\[2])+mat\[0]\[3],\n                (a.x*mat\[1]\[0])+(a.y*mat\[1]\[1])+(a.z*mat\[1]\[2])+mat\[1]\[3],\n                (a.x*mat\[2]\[0])+(a.y*mat\[2]\[1])+(a.z*mat\[2]\[2])+mat\[2]\[3],\n                (a.x*mat\[3]\[0])+(a.y*mat\[3]\[1])+(a.z*mat\[3]\[2])+mat\[3]\[3]);\n\}\nfloat angleOfView(float aperture, float focalLength)\{\n  return 2.0f * atan( 0.5f * aperture / focalLength);\n\}\nfloat4x4 projectionMatrix(float aov, float aspect)\{\n  float4x4 M;\n  // X\n  M\[0]\[0] = 1.0f / (aspect * tan(aov / 2.0f));\n  M\[0]\[1] = 0.0;\n  M\[0]\[2] = 0.0;\n  M\[0]\[3] = 0.0;\n  // Y\n  M\[1]\[0] = 0.0;\n  M\[1]\[1] = 1.0f / tan(aov / 2.0f);\n  M\[1]\[2] = 0.0;\n  M\[1]\[3] = 0.0;\n  // Z\n  M\[2]\[0] = 0.0;\n  M\[2]\[1] = 0.0;\n  M\[2]\[2] = 1.0;\n  M\[2]\[3] = 0.0;\n  // Offset\n  M\[3]\[0] = 0.0;\n  M\[3]\[1] = 0.0;\n  M\[3]\[2] = -1.0;\n  M\[3]\[3] = 0.0;\n  return M;\n\}\n\nfloat3 viewToNDC(float3 point, float4x4 projectionMatrix)\{\n  /*\n  Applies a projection matrix to a point.\n  Components XY end up between 0-1\n  Component Z stays the same\n  */\n  float4 point4 = color(point, 1);\n  point4 = mult(point4, projectionMatrix);\n  float3 point3 = vector(point4) / float3(point4.w, point4.w, 1);\n  return point3 * float3(0.5, 0.5, 1.0) + float3(0.5, 0.5, 0);\n\}\n\n\nkernel SSAO : ImageComputationKernel<ePixelWise>\n\{\n    // Sources\n    Image<eRead, eAccessRandom, eEdgeClamped> inViewSpaceP;\n    Image<eRead, eAccessPoint, eEdgeClamped> inViewSpaceN;\n    Image<eRead, eAccessRandom, eEdgeClamped> inSamples;\n    Image<eRead, eAccessRandom, eEdgeClamped> inRandRots;\n    Image<eWrite> dst;\n\n    param:\n        // Sampling\n        int samples;\n        int rotations;\n        float radius;\n        float bias;\n        // Camera\n        int width;\n        int height;\n        float focal;\n        float haperture;\n\n    local:\n        // Camera\n        float aspect;\n        float4x4 projection;\n\n    void init() \{\n      // Camera\n      aspect = float(width) / float(height);\n      float aov = angleOfView(haperture, focal * aspect);\n      projection = projectionMatrix(aov, aspect);\n        \n    \}\n\n    void process(int2 pos) \{\n        // Samples\n        SampleType(inViewSpaceP) Pcolor = inViewSpaceP(pos.x, pos.y);\n        float3 viewPos = vector(Pcolor);\n        SampleType(inViewSpaceN) Ncolor = inViewSpaceN();\n        float3 normal = norm(vector(Ncolor));\n        SampleType(inRandRots) inRandRotsColor = inRandRots(fmod(pos.x, rotations), fmod(pos.y, rotations));\n        float3 randRot = vector(inRandRotsColor);\n\n        // Matrix from tangentSpace to ViewSpace\n        float3 tangent   = norm(randRot - normal * dot(randRot, normal));\n        float3 bitangent = cross(normal, tangent);\n        float4x4 TBN = matrix4x4(tangent, bitangent, normal);\n\n        // Out of loop declarations\n        SampleType(inSamples) inSamplesColor;\n        SampleType(inViewSpaceP) viewHemiProjPosColor;\n        float occlusion = 0.0;\n        float rangeCheck = 1.0f;\n        float3 tangentHemi;\n        float3 viewHemi;\n        float3 hemiP;\n        float3 samplePos;\n        float3 viewHemiPos;\n        float3 ndcHemiPos;\n        float3 viewHemiProjPos;\n        int2 rasterHemiPos;\n\n        for(int i = 0; i < samples; ++i) // Loop over Hemisphere samples\n        \{\n          // Get ScreenSpace position of hemisphere sample\n          inSamplesColor = inSamples(i, 0);\n          tangentHemi = vector(inSamplesColor); // Hemisphere sample\n          viewHemi = mult(tangentHemi, TBN); // from tangent to viewSpace\n          viewHemiPos = viewPos + viewHemi * radius; // Add Hemisphere sample to Position\n          ndcHemiPos = viewToNDC(viewHemiPos, projection); // viewSpace to NDC\n\n          // Get the position overlaping in screenSpace the hemisphere sample position\n          rasterHemiPos.x = width * ndcHemiPos.x;\n          rasterHemiPos.y = height * ndcHemiPos.y;\n          viewHemiProjPosColor = inViewSpaceP(rasterHemiPos.x, rasterHemiPos.y);\n          viewHemiProjPos = vector(viewHemiProjPosColor);\n\n          // Occlude if projected position is closer to camera than the hemisphere sample\n          if(viewHemiProjPos.z >= viewHemiPos.z + bias)\{\n            rangeCheck = smoothstep(0.0, 1.0, radius / fabs(viewHemiPos.z - viewHemiProjPos.z)); // Disregard if too far\n            occlusion += 1.0 * rangeCheck;\n          \}\n        \} \n        occlusion = 1.0f - (occlusion / float(samples)); // Normalize\n        dst() = occlusion;\n    \}\n\};\n"
  rebuild ""
  SSAO_samples {{parent.samples}}
  SSAO_rotations 64
  SSAO_radius {{parent.radius}}
  SSAO_bias {{parent.threshold}}
  SSAO_width {{width}}
  SSAO_height {{height}}
  SSAO_focal {{"\[topnode parent.input1].focal"}}
  SSAO_haperture {{"\[topnode parent.input1].haperture"}}
  rebuild_finalise ""
  name BlinkScript2
  xpos 0
  ypos 351
 }
set N3a0f8e20 [stack 0]
 Reformat {
  type scale
  resize none
  center false
  name Reformat3
  xpos 0
  ypos 389
 }
set Nb3feb730 [stack 0]
 Invert {
  name Invert2
  xpos 0
  ypos 477
 }
 Grade {
  multiply {{parent.intensity}}
  name Grade7
  xpos 0
  ypos 515
 }
 SoftClip {
  conversion "logarithmic compress"
  softclip_min {{parent.soften}}
  softclip_max {{parent.maxocc}}
  name SoftClip1
  xpos 0
  ypos 541
 }
 Invert {
  name Invert3
  xpos 0
  ypos 567
 }
 Output {
  name Output1
  xpos 0
  ypos 630
 }
push $Nb3feb730
push $N3a0f8e20
push 0
 Viewer {
  inputs 3
  frame 11
  frame_range 1-100
  input_number 2
  viewerProcess None
  name Viewer1
  xpos 110
  ypos 38
 }
end_group
