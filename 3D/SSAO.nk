add_layer {P P.red P.green P.blue P.X P.Y P.Z P.alpha}
add_layer {N N.red N.green N.blue}
Group {
 name SSAO
 selected true
 addUserKnob {20 User l SSAO}
 addUserKnob {41 in l "worldSpace Position" T ViewSpaceP.in}
 addUserKnob {41 in_1 l "worldSpace Normal" T ViewSpaceN.in}
 addUserKnob {26 ""}
 addUserKnob {7 radius l Radius}
 radius 0.5
 addUserKnob {26 ""}
 addUserKnob {7 falloff l Falloff}
 falloff 0.5
 addUserKnob {7 intensity l Intensity R 0 5}
 intensity 3
 addUserKnob {7 soften l "Soften above"}
 soften 0.5
 addUserKnob {7 maxocc l Maximum}
 maxocc 0.7
 addUserKnob {26 ""}
 addUserKnob {3 samples l Samples}
 samples 4096
 addUserKnob {7 dither R 0 0.1}
 dither 0.1
 addUserKnob {3 seed l Seed}
 addUserKnob {7 threshold l "error threshold" R 1e-05 0.1}
 threshold 0.025
}
 Radial {
  inputs 0
  area {480 270 1440 810}
  name Radial1
  xpos 1039
  ypos -17
 }
 Expression {
  channel0 rgba
  expr0 random(x)
  name Expression3
  xpos 1039
  ypos 38
 }
 Constant {
  inputs 0
  channels rgb
  name Constant3
  xpos 800
  ypos 87
 }
 Reformat {
  type "to box"
  box_width {{BlinkScript2.SSAO_rotations}}
  box_height {{BlinkScript2.SSAO_rotations}}
  box_fixed true
  resize none
  center false
  name Reformat2
  xpos 800
  ypos 159
 }
set N67f70e00 [stack 0]
 Expression {
  expr0 cos(random(x+(y*height)+(parent.seed*width*height))*pi()*2*parent.dither)
  expr1 sin(random((parent.seed*height*width)+(width*height)+y+(x*width))*pi()*2*parent.dither)
  expr2 0
  name Expression8
  xpos 800
  ypos 238
 }
 Dot {
  name Dot6
  xpos 834
  ypos 461
 }
 Dot {
  name Dot4
  xpos 378
  ypos 461
 }
 Constant {
  inputs 0
  channels rgb
  name Constant2
  xpos 387
  ypos 66
 }
 Reformat {
  type "to box"
  box_width {{BlinkScript2.SSAO_samples}}
  box_height 1
  box_fixed true
  resize none
  name Reformat1
  xpos 387
  ypos 138
 }
set N72701880 [stack 0]
 Dot {
  name Dot10
  xpos 550
  ypos 142
 }
 Expression {
  channel0 rgba
  expr0 (x)/width
  name Expression2
  xpos 516
  ypos 176
 }
 Gamma {
  channels rgba
  value {{parent.falloff}}
  name Gamma1
  xpos 516
  ypos 228
 }
 Grade {
  black {{parent.threshold}}
  name Grade2
  xpos 516
  ypos 254
 }
 Dot {
  name Dot9
  xpos 550
  ypos 316
 }
push $N72701880
 Expression {
  expr0 (random(x+(parent.seed*width))*2)-1
  expr1 (random(width+x+(parent.seed*width))*2)-1
  expr2 random((2*width)+x+(parent.seed*width))
  name Expression5
  label "Hemisphere\nSamples"
  xpos 387
  ypos 198
 }
 Merge2 {
  inputs 2
  operation multiply
  name Merge1
  xpos 387
  ypos 312
 }
 Dot {
  name Dot5
  xpos 421
  ypos 361
 }
 Input {
  inputs 0
  name Camera
  xpos -275
  ypos -41
  number 1
 }
 Dot {
  name Dot1
  xpos -241
  ypos 42
 }
set Na591ce00 [stack 0]
 Dot {
  name Dot2
  xpos -241
  ypos 85
 }
push $Na591ce00
 Input {
  inputs 0
  name Input
  xpos 0
  ypos -57
 }
set Na591c700 [stack 0]
 Group {
  inputs 2
  name ViewSpaceP
  label Position
  xpos 0
  ypos 32
  addUserKnob {20 User l ScreenSpaceTransform}
  addUserKnob {41 in l Vector T vectorIn.in}
  addUserKnob {6 project +STARTLINE}
  addUserKnob {6 isNormal +STARTLINE}
  addUserKnob {6 invert +STARTLINE}
 }
  Input {
   inputs 0
   name Camera
   xpos 752
   ypos -52
   number 1
  }
  Input {
   inputs 0
   name Vector
   xpos 220
   ypos -48
  }
  Dot {
   name Dot1
   xpos 254
   ypos 1
  }
set N47b2fc00 [stack 0]
  Dot {
   name Dot2
   xpos 403
   ypos 1
  }
  Shuffle {
   in P
   name vectorIn
   xpos 369
   ypos 51
  }
  BlinkScript {
   recompileCount 268
   ProgramGroup 1
   KernelDescription "2 \"SaturationKernel\" iterate pixelWise 3a50bfff32b58b54a88217da56a4dae927eec9541acd2fe5c5c9b015f01db8be 2 \"Vector\" Read Point \"dst\" Write Point 10 \"focalLength\" Float 1 AAAAAA== \"hape\" Float 1 AAAAAA== \"width\" Int 1 AAAAAA== \"height\" Int 1 AAAAAA== \"Near\" Float 1 zczMPQ== \"Far\" Float 1 AEAcRg== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"project\" Int 1 AAAAAA== \"invert\" Int 1 AAAAAA== \"isNormal\" Int 1 AAAAAA== 10 \"focalLength\" 1 1 \"hape\" 1 1 \"width\" 1 1 \"height\" 1 1 \"near\" 1 1 \"far\" 1 1 \"transform\" 16 1 \"project\" 1 1 \"invert\" 1 1 \"isNormal\" 1 1 5 \"aov\" Float 1 1 AAAAAA== \"transformInverted\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraProjection\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"aspect\" Float 1 1 AAAAAA== \"transformNormal\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
   kernelSource "#define PI 3.1415926535897932384626433832795028841971693993751058;\n\nfloat3 norm(float3 a)\{\n  return a/length(a);\n\}\n\nfloat4x4 ident4x4()\{\n  float4x4 mat;\n  mat\[0]\[0] = 1.0;\n  mat\[0]\[1] = 0.0;\n  mat\[0]\[2] = 0.0;\n  mat\[0]\[3] = 0.0;\n  mat\[1]\[0] = 0.0;\n  mat\[1]\[1] = 1.0;\n  mat\[1]\[2] = 0.0;\n  mat\[1]\[3] = 0.0;\n  mat\[2]\[0] = 0.0;\n  mat\[2]\[1] = 0.0;\n  mat\[2]\[2] = 1.0;\n  mat\[2]\[3] = 0.0;\n  mat\[3]\[0] = 0.0;\n  mat\[3]\[1] = 0.0;\n  mat\[3]\[2] = 0.0;\n  mat\[3]\[3] = 1.0;\n  return mat;\n\}\n\nfloat4x4 rotateAxis(float angle, int axis)\{\n  float4x4 mat = ident4x4();\n  if(axis==0)\{      // X\n    mat\[1]\[1] =  cos(angle);\n    mat\[1]\[2] = -sin(angle);\n    mat\[2]\[1] =  sin(angle);\n    mat\[2]\[2] =  cos(angle);\n  \}else if(axis==1)\{// Y\n    mat\[0]\[0] =  cos(angle);\n    mat\[0]\[2] =  sin(angle);\n    mat\[2]\[0] = -sin(angle);\n    mat\[2]\[2] =  cos(angle);\n  \}else if(axis==2)\{// Z\n    mat\[0]\[0] =  cos(angle);\n    mat\[0]\[1] = -sin(angle);\n    mat\[1]\[0] =  sin(angle);\n    mat\[1]\[1] =  cos(angle);\n  \}\n  return mat;\n\}\n\nfloat3 mult(float3 a, float4x4 mat)\{\n  return float3((a.x*mat\[0]\[0])+(a.y*mat\[0]\[1])+(a.z*mat\[0]\[2])+mat\[0]\[3],\n                (a.x*mat\[1]\[0])+(a.y*mat\[1]\[1])+(a.z*mat\[1]\[2])+mat\[1]\[3],\n                (a.x*mat\[2]\[0])+(a.y*mat\[2]\[1])+(a.z*mat\[2]\[2])+mat\[2]\[3]);\n\}\n\nfloat3 multPointMatrix(float3 in,  float4x4 M) \n\{ \n    float3 out = float3(0,0,0);\n    out.x   = in.x * M\[0]\[0] + in.y * M\[0]\[1] + in.z * M\[0]\[2] + M\[0]\[3]; \n    out.y   = in.x * M\[1]\[0] + in.y * M\[1]\[1] + in.z * M\[1]\[2] + M\[1]\[3]; \n    out.z   = in.x * M\[2]\[0] + in.y * M\[2]\[1] + in.z * M\[2]\[2] + M\[2]\[3]; \n    float w = in.x * M\[3]\[0] + in.y * M\[3]\[1] + in.z * M\[3]\[2] + M\[3]\[3]; \n \n    // normalize if w is different than 1 (convert from homogeneous to Cartesian coordinates)\n    if (w != 1) \{ \n        out.x /= w; \n        out.y /= w; \n        //out.z /= w; \n    \}\n    return out;\n\}\nfloat3 divPointMatrix(float3 in,  float4x4 M) \n\{ \n    float w = in.x * M\[3]\[0] + in.y * M\[3]\[1] + in.z * M\[3]\[2] + M\[3]\[3];;\n    // normalize if w is different than 1 (convert from homogeneous to Cartesian coordinates)\n    if (w != 1) \{ \n        in.x *= w; \n        in.y *= w; \n        //out.z /= w; \n    \}\n    float3 out = float3(0,0,0);\n    out.x   = in.x / M\[0]\[0]; \n    out.y   = in.y / M\[1]\[1]; \n    out.z   = in.z / M\[2]\[2]; \n\n \n    return out;\n\}\n\nfloat4x4 projectionMatrix(float aov, float aspect, float near, float far)\{\n  float4x4 M = ident4x4();\n  // X\n  M\[0]\[0] = 1.0f / (aspect * tan(aov / 2.0f)); // scale the x coordinates of the projected point \n  M\[0]\[1] = 0.0;\n  M\[0]\[2] = 0.0;\n  M\[0]\[3] = 0.0;\n  // Y\n  M\[1]\[0] = 0.0;\n  M\[1]\[1] = 1.0f / tan(aov / 2.0f); // scale the y coordinates of the projected point \n  M\[1]\[2] = 0.0;\n  M\[1]\[3] = 0.0;\n  // Z\n  M\[2]\[0] = 0.0;\n  M\[2]\[1] = 0.0;\n  //M\[2]\[2] = far / (far - near);\n  //M\[2]\[3] = -far * near / (far - near);\n  // Offset\n  M\[3]\[0] = 0.0;\n  M\[3]\[1] = 0.0;\n  M\[3]\[2] = -1.0;\n  M\[3]\[3] = 0.0;\n  return M;\n\}\n\n\nfloat angleOfView(float aperture, float focalLength)\{\n  return 2.0f * atan( 0.5f * aperture / focalLength);\n\}\n\n\n\nkernel SaturationKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> Vector; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    float focalLength;\n    float hape;\n    int width;\n    int height;\n    float near;\n    float far;\n    float4x4 transform;\n    int project;\n    int invert;\n    int isNormal;\n\n  local:\n    float aov;\n    float4x4 transformInverted;\n    float4x4 cameraProjection;\n    float aspect;\n    float4x4 transformNormal;\n\n  void define() \{\n    defineParam(near, \"Near\", 0.1f);\n    defineParam(far, \"Far\", 10000.0f);\n  \}\n\n  void init() \{\n    aspect = float(width) / float(height);\n    aov = angleOfView(hape, focalLength * aspect);\n\n    cameraProjection = projectionMatrix(aov, aspect, near, far);\n\n    transformInverted = transform.invert();\n    transformNormal = transform;\n    if( isNormal == 1 )\{\n      transformInverted\[0]\[3] = 0.0f;\n      transformInverted\[1]\[3] = 0.0f;\n      transformInverted\[2]\[3] = 0.0f;\n      transformNormal\[0]\[3] = 0.0;\n      transformNormal\[1]\[3] = 0.0f;\n      transformNormal\[2]\[3] = 0.0f;\n    \}\n\n  \}\n\n\n\n  void process(int2 pos) \{\n    // Read the input image\n    SampleType(Vector) input  = Vector();\n    float3 v = float3(input\[0], input\[1], input\[2]);\n\n    float screenOffsetX = float(pos.x) / float(width);\n    screenOffsetX = (screenOffsetX * 2.0f) - 1.0f;\n    float screenOffsetY = float(pos.y) / float(height);\n    screenOffsetY = (screenOffsetY * 2.0f) - 1.0f;\n\n    if(invert == 0)\{\n      v = mult(v, transformInverted);\n      if( project == 1 )\{\n        if( isNormal == 1 )\{\n          float4x4 rotY = rotateAxis( aov * screenOffsetX * 0.5f * aspect, 1 );\n          float4x4 rotX = rotateAxis( aov * -screenOffsetY * 0.5f, 0 );\n          v = mult(v, rotY);\n          v = mult(v, rotX);\n        \}else\{\n          v = multPointMatrix(v, cameraProjection);\n        \}\n      \}\n    \}else\{\n      if( project == 1 )\{\n        if( isNormal == 1 )\{\n          float4x4 rotY = rotateAxis( aov * -screenOffsetX * 0.5f * aspect, 1 );\n          float4x4 rotX = rotateAxis( aov * screenOffsetY * 0.5f, 0 );\n          v = mult(v, rotX);\n          v = mult(v, rotY);\n        \}else\{\n          v = divPointMatrix(v, cameraProjection);\n        \}\n      \}\n      v = mult(v, transformNormal);\n    \}\n    if( isNormal == 1 )\{\n      v = norm(v);\n    \}\n    dst() = float4(v\[0], v\[1], v\[2], 0.0f);\n  \}\n\};\n"
   rebuild ""
   SaturationKernel_focalLength {{Camera1.focal}}
   SaturationKernel_hape {{Camera1.haperture}}
   SaturationKernel_width {{width}}
   SaturationKernel_height {{height}}
   SaturationKernel_Near {{Camera1.near}}
   SaturationKernel_Far {{Camera1.far}}
   group_SaturationKernel_transform 1
   SaturationKernel_transform {
       {{Camera1.world_matrix.0} {Camera1.world_matrix.1} {Camera1.world_matrix.2} {Camera1.world_matrix.3}}
       {{Camera1.world_matrix.4} {Camera1.world_matrix.5} {Camera1.world_matrix.6} {Camera1.world_matrix.7}}
       {{Camera1.world_matrix.8} {Camera1.world_matrix.9} {Camera1.world_matrix.10} {Camera1.world_matrix.11}}
       {{Camera1.world_matrix.12} {Camera1.world_matrix.13} {Camera1.world_matrix.14} {Camera1.world_matrix.15}}
     }
   SaturationKernel_project {{parent.project}}
   SaturationKernel_invert {{parent.invert}}
   SaturationKernel_isNormal {{parent.isNormal}}
   rebuild_finalise ""
   name BlinkScript4
   xpos 369
   ypos 154
  }
  Dot {
   name Dot3
   xpos 403
   ypos 274
  }
push $N47b2fc00
  ShuffleCopy {
   inputs 2
   in2 {{{vectorIn.in}}}
   red red
   green green
   blue blue
   alpha alpha2
   out {{{vectorIn.in}}}
   name ShuffleCopy1
   xpos 220
   ypos 270
  }
  Output {
   name Output1
   xpos 220
   ypos 313
  }
  Camera2 {
   inputs 0
   useMatrix true
   matrix {
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
     }
   focal {{"\[topnode parent.parent.input1].focal"}}
   haperture {{"\[topnode parent.parent.input1].haperture"}}
   near {{"\[topnode parent.parent.input1].near"}}
   far {{"\[topnode parent.parent.input1].far"}}
   name Camera1
   selected true
   xpos 762
   ypos 5
  }
 end_group
 Group {
  inputs 2
  name ViewSpaceN
  label Normal
  xpos 0
  ypos 75
  addUserKnob {20 User l ScreenSpaceTransform}
  addUserKnob {41 in l Vector T vectorIn.in}
  addUserKnob {6 project +STARTLINE}
  addUserKnob {6 isNormal +STARTLINE}
  isNormal true
  addUserKnob {6 invert +STARTLINE}
 }
  Input {
   inputs 0
   name Camera
   xpos 752
   ypos -52
   number 1
  }
  Input {
   inputs 0
   name Vector
   xpos 220
   ypos -48
  }
  Dot {
   name Dot1
   xpos 254
   ypos 1
  }
set N3c757880 [stack 0]
  Dot {
   name Dot2
   xpos 403
   ypos 1
  }
  Shuffle {
   in N
   name vectorIn
   xpos 369
   ypos 51
  }
  BlinkScript {
   recompileCount 268
   ProgramGroup 1
   KernelDescription "2 \"SaturationKernel\" iterate pixelWise 3a50bfff32b58b54a88217da56a4dae927eec9541acd2fe5c5c9b015f01db8be 2 \"Vector\" Read Point \"dst\" Write Point 10 \"focalLength\" Float 1 AAAAAA== \"hape\" Float 1 AAAAAA== \"width\" Int 1 AAAAAA== \"height\" Int 1 AAAAAA== \"Near\" Float 1 zczMPQ== \"Far\" Float 1 AEAcRg== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"project\" Int 1 AAAAAA== \"invert\" Int 1 AAAAAA== \"isNormal\" Int 1 AAAAAA== 10 \"focalLength\" 1 1 \"hape\" 1 1 \"width\" 1 1 \"height\" 1 1 \"near\" 1 1 \"far\" 1 1 \"transform\" 16 1 \"project\" 1 1 \"invert\" 1 1 \"isNormal\" 1 1 5 \"aov\" Float 1 1 AAAAAA== \"transformInverted\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"cameraProjection\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"aspect\" Float 1 1 AAAAAA== \"transformNormal\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
   kernelSource "#define PI 3.1415926535897932384626433832795028841971693993751058;\n\nfloat3 norm(float3 a)\{\n  return a/length(a);\n\}\n\nfloat4x4 ident4x4()\{\n  float4x4 mat;\n  mat\[0]\[0] = 1.0;\n  mat\[0]\[1] = 0.0;\n  mat\[0]\[2] = 0.0;\n  mat\[0]\[3] = 0.0;\n  mat\[1]\[0] = 0.0;\n  mat\[1]\[1] = 1.0;\n  mat\[1]\[2] = 0.0;\n  mat\[1]\[3] = 0.0;\n  mat\[2]\[0] = 0.0;\n  mat\[2]\[1] = 0.0;\n  mat\[2]\[2] = 1.0;\n  mat\[2]\[3] = 0.0;\n  mat\[3]\[0] = 0.0;\n  mat\[3]\[1] = 0.0;\n  mat\[3]\[2] = 0.0;\n  mat\[3]\[3] = 1.0;\n  return mat;\n\}\n\nfloat4x4 rotateAxis(float angle, int axis)\{\n  float4x4 mat = ident4x4();\n  if(axis==0)\{      // X\n    mat\[1]\[1] =  cos(angle);\n    mat\[1]\[2] = -sin(angle);\n    mat\[2]\[1] =  sin(angle);\n    mat\[2]\[2] =  cos(angle);\n  \}else if(axis==1)\{// Y\n    mat\[0]\[0] =  cos(angle);\n    mat\[0]\[2] =  sin(angle);\n    mat\[2]\[0] = -sin(angle);\n    mat\[2]\[2] =  cos(angle);\n  \}else if(axis==2)\{// Z\n    mat\[0]\[0] =  cos(angle);\n    mat\[0]\[1] = -sin(angle);\n    mat\[1]\[0] =  sin(angle);\n    mat\[1]\[1] =  cos(angle);\n  \}\n  return mat;\n\}\n\nfloat3 mult(float3 a, float4x4 mat)\{\n  return float3((a.x*mat\[0]\[0])+(a.y*mat\[0]\[1])+(a.z*mat\[0]\[2])+mat\[0]\[3],\n                (a.x*mat\[1]\[0])+(a.y*mat\[1]\[1])+(a.z*mat\[1]\[2])+mat\[1]\[3],\n                (a.x*mat\[2]\[0])+(a.y*mat\[2]\[1])+(a.z*mat\[2]\[2])+mat\[2]\[3]);\n\}\n\nfloat3 multPointMatrix(float3 in,  float4x4 M) \n\{ \n    float3 out = float3(0,0,0);\n    out.x   = in.x * M\[0]\[0] + in.y * M\[0]\[1] + in.z * M\[0]\[2] + M\[0]\[3]; \n    out.y   = in.x * M\[1]\[0] + in.y * M\[1]\[1] + in.z * M\[1]\[2] + M\[1]\[3]; \n    out.z   = in.x * M\[2]\[0] + in.y * M\[2]\[1] + in.z * M\[2]\[2] + M\[2]\[3]; \n    float w = in.x * M\[3]\[0] + in.y * M\[3]\[1] + in.z * M\[3]\[2] + M\[3]\[3]; \n \n    // normalize if w is different than 1 (convert from homogeneous to Cartesian coordinates)\n    if (w != 1) \{ \n        out.x /= w; \n        out.y /= w; \n        //out.z /= w; \n    \}\n    return out;\n\}\nfloat3 divPointMatrix(float3 in,  float4x4 M) \n\{ \n    float w = in.x * M\[3]\[0] + in.y * M\[3]\[1] + in.z * M\[3]\[2] + M\[3]\[3];;\n    // normalize if w is different than 1 (convert from homogeneous to Cartesian coordinates)\n    if (w != 1) \{ \n        in.x *= w; \n        in.y *= w; \n        //out.z /= w; \n    \}\n    float3 out = float3(0,0,0);\n    out.x   = in.x / M\[0]\[0]; \n    out.y   = in.y / M\[1]\[1]; \n    out.z   = in.z / M\[2]\[2]; \n\n \n    return out;\n\}\n\nfloat4x4 projectionMatrix(float aov, float aspect, float near, float far)\{\n  float4x4 M = ident4x4();\n  // X\n  M\[0]\[0] = 1.0f / (aspect * tan(aov / 2.0f)); // scale the x coordinates of the projected point \n  M\[0]\[1] = 0.0;\n  M\[0]\[2] = 0.0;\n  M\[0]\[3] = 0.0;\n  // Y\n  M\[1]\[0] = 0.0;\n  M\[1]\[1] = 1.0f / tan(aov / 2.0f); // scale the y coordinates of the projected point \n  M\[1]\[2] = 0.0;\n  M\[1]\[3] = 0.0;\n  // Z\n  M\[2]\[0] = 0.0;\n  M\[2]\[1] = 0.0;\n  //M\[2]\[2] = far / (far - near);\n  //M\[2]\[3] = -far * near / (far - near);\n  // Offset\n  M\[3]\[0] = 0.0;\n  M\[3]\[1] = 0.0;\n  M\[3]\[2] = -1.0;\n  M\[3]\[3] = 0.0;\n  return M;\n\}\n\n\nfloat angleOfView(float aperture, float focalLength)\{\n  return 2.0f * atan( 0.5f * aperture / focalLength);\n\}\n\n\n\nkernel SaturationKernel : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> Vector; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    float focalLength;\n    float hape;\n    int width;\n    int height;\n    float near;\n    float far;\n    float4x4 transform;\n    int project;\n    int invert;\n    int isNormal;\n\n  local:\n    float aov;\n    float4x4 transformInverted;\n    float4x4 cameraProjection;\n    float aspect;\n    float4x4 transformNormal;\n\n  void define() \{\n    defineParam(near, \"Near\", 0.1f);\n    defineParam(far, \"Far\", 10000.0f);\n  \}\n\n  void init() \{\n    aspect = float(width) / float(height);\n    aov = angleOfView(hape, focalLength * aspect);\n\n    cameraProjection = projectionMatrix(aov, aspect, near, far);\n\n    transformInverted = transform.invert();\n    transformNormal = transform;\n    if( isNormal == 1 )\{\n      transformInverted\[0]\[3] = 0.0f;\n      transformInverted\[1]\[3] = 0.0f;\n      transformInverted\[2]\[3] = 0.0f;\n      transformNormal\[0]\[3] = 0.0;\n      transformNormal\[1]\[3] = 0.0f;\n      transformNormal\[2]\[3] = 0.0f;\n    \}\n\n  \}\n\n\n\n  void process(int2 pos) \{\n    // Read the input image\n    SampleType(Vector) input  = Vector();\n    float3 v = float3(input\[0], input\[1], input\[2]);\n\n    float screenOffsetX = float(pos.x) / float(width);\n    screenOffsetX = (screenOffsetX * 2.0f) - 1.0f;\n    float screenOffsetY = float(pos.y) / float(height);\n    screenOffsetY = (screenOffsetY * 2.0f) - 1.0f;\n\n    if(invert == 0)\{\n      v = mult(v, transformInverted);\n      if( project == 1 )\{\n        if( isNormal == 1 )\{\n          float4x4 rotY = rotateAxis( aov * screenOffsetX * 0.5f * aspect, 1 );\n          float4x4 rotX = rotateAxis( aov * -screenOffsetY * 0.5f, 0 );\n          v = mult(v, rotY);\n          v = mult(v, rotX);\n        \}else\{\n          v = multPointMatrix(v, cameraProjection);\n        \}\n      \}\n    \}else\{\n      if( project == 1 )\{\n        if( isNormal == 1 )\{\n          float4x4 rotY = rotateAxis( aov * -screenOffsetX * 0.5f * aspect, 1 );\n          float4x4 rotX = rotateAxis( aov * screenOffsetY * 0.5f, 0 );\n          v = mult(v, rotX);\n          v = mult(v, rotY);\n        \}else\{\n          v = divPointMatrix(v, cameraProjection);\n        \}\n      \}\n      v = mult(v, transformNormal);\n    \}\n    if( isNormal == 1 )\{\n      v = norm(v);\n    \}\n    dst() = float4(v\[0], v\[1], v\[2], 0.0f);\n  \}\n\};\n"
   rebuild ""
   SaturationKernel_focalLength {{Camera1.focal}}
   SaturationKernel_hape {{Camera1.haperture}}
   SaturationKernel_width {{width}}
   SaturationKernel_height {{height}}
   SaturationKernel_Near {{Camera1.near}}
   SaturationKernel_Far {{Camera1.far}}
   group_SaturationKernel_transform 1
   SaturationKernel_transform {
       {{Camera1.world_matrix.0} {Camera1.world_matrix.1} {Camera1.world_matrix.2} {Camera1.world_matrix.3}}
       {{Camera1.world_matrix.4} {Camera1.world_matrix.5} {Camera1.world_matrix.6} {Camera1.world_matrix.7}}
       {{Camera1.world_matrix.8} {Camera1.world_matrix.9} {Camera1.world_matrix.10} {Camera1.world_matrix.11}}
       {{Camera1.world_matrix.12} {Camera1.world_matrix.13} {Camera1.world_matrix.14} {Camera1.world_matrix.15}}
     }
   SaturationKernel_project {{parent.project}}
   SaturationKernel_invert {{parent.invert}}
   SaturationKernel_isNormal {{parent.isNormal}}
   rebuild_finalise ""
   name BlinkScript4
   xpos 369
   ypos 154
  }
  Dot {
   name Dot3
   xpos 403
   ypos 274
  }
push $N3c757880
  ShuffleCopy {
   inputs 2
   in2 {{{vectorIn.in}}}
   red red
   green green
   blue blue
   alpha alpha2
   out {{{vectorIn.in}}}
   name ShuffleCopy1
   xpos 220
   ypos 270
  }
  Output {
   name Output1
   xpos 220
   ypos 313
  }
  Camera2 {
   inputs 0
   useMatrix true
   matrix {
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
       {{"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"} {"\[topnode parent.parent.input1].world_matrix"}}
     }
   focal {{"\[topnode parent.parent.input1].focal"}}
   haperture {{"\[topnode parent.parent.input1].haperture"}}
   near {{"\[topnode parent.parent.input1].near"}}
   far {{"\[topnode parent.parent.input1].far"}}
   name Camera1
   selected true
   xpos 762
   ypos 5
  }
 end_group
 Dot {
  name Dot7
  xpos 34
  ypos 164
 }
set N55b2bc00 [stack 0]
 Dot {
  name Dot8
  xpos -112
  ypos 164
 }
 Shuffle {
  in {{{ViewSpaceN.vectorIn.in}}}
  name Shuffle1
  label "ViewSpace\nNormal"
  xpos -146
  ypos 200
  postage_stamp true
 }
 Dot {
  name Dot3
  xpos -112
  ypos 361
 }
push $Na591c700
 Shuffle {
  in {{{ViewSpaceP.vectorIn.in}}}
  name Shuffle3
  xpos 228
  ypos 98
 }
 Group {
  name Vector
  knobChanged "n = nuke.thisNode()\nk = nuke.thisKnob()\n\ndef value(vis):\n  if(vis==True):\n\tn.knob(\"constant\").setVisible(True)\n\tn.knob(\"uniform\").setVisible(True)\n\tif(n.knob(\"constant\").value()==True):\n\t  if(n.knob(\"uniform\").value()==True):\n\t\tn.knob(\"value\").setVisible(True)\n\t\tn.knob(\"value2\").setVisible(False)\n\t\tn.knob(\"value3\").setVisible(False)\n\t  else:\n\t\tn.knob(\"value\").setVisible(False)\n\t\tif(n.knob(\"size\").value()==\"2\"):\n\t\t  n.knob(\"value2\").setVisible(True)\n\t\t  n.knob(\"value3\").setVisible(False)\n\t\telif(n.knob(\"size\").value()==\"3\"):\n\t\t  n.knob(\"value2\").setVisible(False)\n\t\t  n.knob(\"value3\").setVisible(True)\n\telse:\n\t  n.knob(\"value\").setVisible(False)\n\t  n.knob(\"value2\").setVisible(False)\n\t  n.knob(\"value3\").setVisible(False)\n\t  n.knob(\"uniform\").setVisible(False)\n  else:\n\tn.knob(\"constant\").setVisible(False)\n\tn.knob(\"value\").setVisible(False)\n\tn.knob(\"value2\").setVisible(False)\n\tn.knob(\"value3\").setVisible(False)\n\tn.knob(\"uniform\").setVisible(False)\n\ndef transform(vis):\n  n.knob(\"transform_order\").setVisible(False)\n  n.knob(\"rotation_order3\").setVisible(False)\n  n.knob(\"rotateunit\").setVisible(False)\n  n.knob(\"constant_trans\").setVisible(False)\n  n.knob(\"translate2\").setVisible(False)\n  n.knob(\"translate3\").setVisible(False)\n  n.knob(\"rotate\").setVisible(False)\n  n.knob(\"rotate3\").setVisible(False)\n  n.knob(\"scale2\").setVisible(False)\n  n.knob(\"scale3\").setVisible(False)\n  n.knob(\"uniformScale\").setVisible(False)\n  n.knob(\"invert\").setVisible(False)\n  n.knob(\"angleBetweenAxis\").setVisible(False)\n  n.knob(\"angleConvertFrom\").setVisible(False)\n  n.knob(\"angleConvertTo\").setVisible(False)\n\n  if(vis==True):\n\tn.knob(\"invert\").setVisible(True)\n\tif(n.knob(\"transform_op\").value()==\"transform\"):\n\t  n.knob(\"transform_order\").setVisible(True)\n\telse:\n\t  n.knob(\"constant_trans\").setVisible(True)\n\n\tif(n.knob(\"transform_op\").value()==\"translate\" or n.knob(\"transform_op\").value()==\"transform\"):\n\t  if(n.knob(\"constant_trans\").value()==True or n.knob(\"transform_op\").value()==\"transform\"):\n\t\tif(n.knob(\"size\").value()==\"2\"):\n\t\t  n.knob(\"translate2\").setVisible(True)\n\t\telse:\n\t\t  n.knob(\"translate3\").setVisible(True)\n\tif(n.knob(\"transform_op\").value()==\"rotate\" or n.knob(\"transform_op\").value()==\"transform\"):\n\t  n.knob(\"rotateunit\").setVisible(True)\n\t  if(n.knob(\"constant_trans\").value()==True or n.knob(\"transform_op\").value()==\"transform\"):\n\t\tif(n.knob(\"size\").value()==\"2\"):\n\t\t  n.knob(\"rotate\").setVisible(True)\n\t\telse:\n\t\t  n.knob(\"rotate3\").setVisible(True)\n\t  if(n.knob(\"size\").value()==\"3\"):\n\t\tn.knob(\"rotation_order3\").setVisible(True)\n\tif(n.knob(\"transform_op\").value()==\"scale\" or n.knob(\"transform_op\").value()==\"transform\"):\n\t  if(n.knob(\"constant_trans\").value()==True or n.knob(\"transform_op\").value()==\"transform\"):\n\t\tn.knob(\"uniformScale\").setVisible(True)\n\t\tif(n.knob(\"size\").value()==\"2\"):\n\t\t  n.knob(\"scale2\").setVisible(True)\n\t\telse:\n\t\t  n.knob(\"scale3\").setVisible(True)\n\ndef size(s):\n  if(s==\"2\"):\n\tn.knob(\"value2\").setVisible(n.knob(\"value3\").visible())\n\tn.knob(\"translate2\").setVisible(n.knob(\"translate3\").visible())\n\tn.knob(\"rotate\").setVisible(n.knob(\"rotate3\").visible())\n\tn.knob(\"scale2\").setVisible(n.knob(\"scale3\").visible())\n\n\tn.knob(\"value3\").setVisible(False)\n\tn.knob(\"rotation_order3\").setVisible(False)\n\tn.knob(\"translate3\").setVisible(False)\n\tn.knob(\"rotate3\").setVisible(False)\n\tn.knob(\"scale3\").setVisible(False)\n\n\tn.knob(\"angleBetweenAxis\").setVisible(False)\n\tif(n.knob(\"category\").value()==\"math\"):\n\t  n.knob(\"math_op2\").setVisible(True)\n\t  n.knob(\"math_op3\").setVisible(False)\n\t  try:\n\t\tn.knob(\"math_op2\").setValue(n.knob(\"math_op3\").value())\n\t  except:\n\t\tpass\n  elif(s==\"3\"):\n\tn.knob(\"value3\").setVisible(n.knob(\"value2\").visible())\n\tn.knob(\"rotation_order3\").setVisible(n.knob(\"rotate\").visible())\n\tn.knob(\"translate3\").setVisible(n.knob(\"translate2\").visible())\n\tn.knob(\"rotate3\").setVisible(n.knob(\"rotate\").visible())\n\tn.knob(\"scale3\").setVisible(n.knob(\"scale2\").visible())\n\n\tn.knob(\"value2\").setVisible(False)\n\tn.knob(\"translate2\").setVisible(False)\n\tn.knob(\"rotate\").setVisible(False)\n\tn.knob(\"scale2\").setVisible(False)\n\n\tif(n.knob(\"category\").value()==\"utility\"):\n\t  if(n.knob(\"utility_op\").value()==\"angle between\"):\n\t\tn.knob(\"angleBetweenAxis\").setVisible(True)\n\n\tif(n.knob(\"category\").value()==\"math\"):\n\t  n.knob(\"math_op2\").setVisible(False)\n\t  n.knob(\"math_op3\").setVisible(True)\n\t  n.knob(\"math_op3\").setValue(n.knob(\"math_op2\").value())\n\ndef uniform():\n  if(n.knob(\"uniform\").value()==True):\n\tn.knob(\"value\").setVisible(True)\n\tn.knob(\"value2\").setVisible(False)\n\tn.knob(\"value3\").setVisible(False)\n  else:\n\tn.knob(\"value\").setVisible(False)\n\tif(n.knob(\"size\").value()==\"2\"):\n\t\tn.knob(\"value2\").setVisible(True)\n\t\tn.knob(\"value3\").setVisible(False)\n\telse:\n\t\tn.knob(\"value2\").setVisible(False)\n\t\tn.knob(\"value3\").setVisible(True)\n\ndef label():\n  sizes = \[\"v2\", \"v3\"]\n  categories = \[\"init\", \"math\", \"trs\",\"util\"]\n  math = \[\"add\", \"sub\",\"mult\", \"div\", \"mod\", \"norm\", \"len\", \"dot\", \"cros\"]\n  trans = \[\"pos\", \"rot\", \"scale\", \" \"]\n  utils = \[\"dist\", \"angle\", \"conv\"]\n  string = \"\"\n  string += sizes\[int(n.knob(\"size\").getValue())]\n  string += \" \"\n  string += categories\[int(n.knob(\"category\").getValue())]\n  string += \" \"\n  if(n.knob(\"category\").value() == \"math\"):\n\tif(n.knob(\"size\").value() == \"2\"):\n\t  string += math\[int(n.knob(\"math_op2\").getValue())]\n\telse:\n\t  string += math\[int(n.knob(\"math_op3\").getValue())]\n  elif(n.knob(\"category\").value() == \"transform\"):\n\tstring += trans\[int(n.knob(\"transform_op\").getValue())]\n  elif(n.knob(\"category\").value() == \"utility\"):\n\tstring += utils\[int(n.knob(\"utility_op\").getValue())]\n\n  n.knob(\"label\").setValue(string)\n\nlabel()\nif(k.name()==\"size\"):\n  size(k.value())\nelif(k.name()==\"category\"):\n  n.knob(\"math_op2\").setVisible(False)\n  n.knob(\"math_op3\").setVisible(False)\n  n.knob(\"transform_op\").setVisible(False)\n  n.knob(\"utility_op\").setVisible(False)\n  if(k.value()==\"initialize\"):\n\tvalue(True)\n\ttransform(False)\n  elif(k.value()==\"math\"):\n\ttransform(False)\n\tif(n.knob(\"size\").value()==\"2\"):\n\t  n.knob(\"math_op2\").setVisible(True)\n\t  n.knob(\"math_op3\").setVisible(False)\n\telse:\n\t  n.knob(\"math_op2\").setVisible(False)\n\t  n.knob(\"math_op3\").setVisible(True)\n\tif(n.knob(\"math_op3\").value()==\"normalize\" or n.knob(\"math_op3\").value()==\"length\"):\n\t  value(False)\n\telse:\n\t  value(True)\n  elif(k.value()==\"transform\"):\n\tn.knob(\"transform_op\").setVisible(True)\n\tvalue(False)\n\ttransform(True)\n  elif(k.value()==\"utility\"):\n\tn.knob(\"utility_op\").setVisible(True)\n\ttransform(False)\n\tvalue(True)\nelif(k.name()==\"math_op2\" and n.knob(\"category\").value()==\"math\"):\n\ttransform(False)\n\tif(n.knob(\"math_op2\").value()==\"normalize\" or n.knob(\"math_op2\").value()==\"length\"):\n\t  value(False)\n\telse:\n\t  value(True)\nelif(k.name()==\"math_op3\" and n.knob(\"category\").value()==\"math\"):\n\ttransform(False)\n\tif(n.knob(\"math_op3\").value()==\"normalize\" or n.knob(\"math_op3\").value()==\"length\"):\n\t  value(False)\n\telse:\n\t  value(True)\nelif(k.name()==\"transform_op\" and n.knob(\"category\").value()==\"transform\"):\n\tvalue(False)\n\ttransform(True)\nelif(k.name()==\"utility_op\" and n.knob(\"category\").value()==\"utility\"):\n  value(True)\n  if(k.value()==\"angle between\" and n.knob(\"size\").value()==\"3\"):\n\tn.knob(\"angleBetweenAxis\").setVisible(True)\n  else:\n\tn.knob(\"angleBetweenAxis\").setVisible(False)\n  if(k.value()==\"angle convert\"):\n\tn.knob(\"angleConvertFrom\").setVisible(True)\n\tn.knob(\"angleConvertTo\").setVisible(True)\n\tvalue(False)\n  else:\n\tn.knob(\"angleConvertFrom\").setVisible(False)\n\tn.knob(\"angleConvertTo\").setVisible(False)\nelif(k.name()==\"constant\"):\n  if(k.value()==False):\n\tn.knob(\"value\").setVisible(False)\n\tn.knob(\"value2\").setVisible(False)\n\tn.knob(\"value3\").setVisible(False)\n\tn.knob(\"uniform\").setVisible(False)\n  else:\n\tn.knob(\"uniform\").setVisible(True)\n\tuniform()\nelif(k.name()==\"uniform\"):\n  uniform()\nelif(k.name()==\"constant_trans\"):\n  transform(True)\n"
  label "v3 math len"
  note_font Verdana
  xpos 228
  ypos 124
  addUserKnob {20 User}
  addUserKnob {26 vector_div l vector}
  addUserKnob {4 size -STARTLINE M {2 3}}
  size 3
  addUserKnob {6 isolate -STARTLINE}
  isolate true
  addUserKnob {26 operation_div l "             operation"}
  addUserKnob {4 category M {initialize math transform utility "" "" ""}}
  category math
  addUserKnob {4 math_op3 l operation -STARTLINE M {add substract multiply divide modulo normalize length dot cross ""}}
  math_op3 length
  addUserKnob {4 math_op2 l operation -STARTLINE +HIDDEN M {add substract multiply divide modulo normalize length dot "" ""}}
  math_op2 normalize
  addUserKnob {4 transform_op l operation -STARTLINE +HIDDEN M {translate rotate scale transform "" "" ""}}
  transform_op transform
  addUserKnob {4 utility_op l operation -STARTLINE +HIDDEN M {distance "angle between" "angle convert" ""}}
  utility_op "angle convert"
  addUserKnob {6 constant +HIDDEN +STARTLINE}
  addUserKnob {6 uniform -STARTLINE +HIDDEN}
  addUserKnob {7 value +HIDDEN}
  addUserKnob {12 value2 l value +HIDDEN}
  addUserKnob {13 value3 l value +HIDDEN}
  addUserKnob {6 blop_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {4 transform_order l transfrom_order +HIDDEN M {SRT STR RST RTS TSR TRS "" "" "" "" "" "" ""}}
  addUserKnob {4 rotation_order3 l "rotation order" +HIDDEN M {XYZ XZY YXZ YZX ZXY ZYX}}
  rotation_order3 ZXY
  addUserKnob {4 rotateunit l unit +HIDDEN M {degrees radians "" "" ""}}
  addUserKnob {6 constant_trans l constant +HIDDEN +STARTLINE}
  addUserKnob {12 translate2 l translate +HIDDEN}
  addUserKnob {13 translate3 l translate +HIDDEN}
  addUserKnob {7 rotate +HIDDEN R 0 360}
  addUserKnob {13 rotate3 l rotate +HIDDEN}
  addUserKnob {12 scale2 l scale +HIDDEN}
  scale2 {1 1}
  addUserKnob {13 scale3 l scale +HIDDEN}
  scale3 {1 1 1}
  addUserKnob {7 uniformScale l "uniform scale" +HIDDEN R 0 10}
  uniformScale 1
  addUserKnob {6 invert +HIDDEN +STARTLINE}
  addUserKnob {13 angleBetweenAxis l axis +HIDDEN}
  angleBetweenAxis {0 1 0}
  addUserKnob {4 angleConvertFrom l from +HIDDEN M {"\[-1, 1]" "\[ 0, 1]" radians degrees "" ""}}
  angleConvertFrom radians
  addUserKnob {4 angleConvertTo l to +HIDDEN M {"\[-1, 1]" "\[ 0, 1]" radians degrees "" "" ""}}
  angleConvertTo degrees
 }
  Constant {
   inputs 0
   channels rgb
   name Constant1
   xpos 126
   ypos 173
  }
  Input {
   inputs 0
   name input
   xpos 256
   ypos 122
  }
  Switch {
   inputs 2
   which {{"1-\[exists parent.input0]"}}
   name Switch2
   xpos 256
   ypos 197
  }
set N55b2a380 [stack 0]
  Remove {
   operation keep
   channels rgba
   name Remove1
   xpos 358
   ypos 197
  }
  Input {
   inputs 0
   name value
   xpos 404
   ypos 119
   number 1
  }
  Switch {
   inputs 2
   which {{"1-\[exists parent.input1]"}}
   name Switch1
   xpos 404
   ypos 248
  }
push $N55b2a380
  BlinkScript {
   inputs 2
   recompileCount 476
   ProgramGroup 1
   KernelDescription "2 \"vector\" iterate pixelWise 5000c4536052845eeca1238857bdf67901bcc199635ff76c60899bd7392186af 3 \"src\" Read Point \"srcB\" Read Point \"dst\" Write Point 27 \"size\" Int 1 AQAAAA== \"isolate\" Int 1 AQAAAA== \"category\" Int 1 AgAAAA== \"math_operation2\" Int 1 BQAAAA== \"math_operation3\" Int 1 BQAAAA== \"transform_operation\" Int 1 AwAAAA== \"utility_operation\" Int 1 AAAAAA== \"constant\" Int 1 AQAAAA== \"value\" Float 1 AAAAAA== \"value2\" Float 2 AAAAAAAAAAA= \"value3\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"uniform\" Int 1 AAAAAA== \"translate2\" Float 2 AAAAAAAAAAA= \"translate3\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"rotate\" Float 1 AAAAAA== \"rotate3\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"rotateunit\" Int 1 AAAAAA== \"scale2\" Float 2 AACAPwAAgD8= \"scale3\" Float 3 AACAPwAAgD8AAIA/AAAAAA== \"uniformScale\" Float 1 AACAPw== \"transform_order\" Int 1 AAAAAA== \"rotate_order3\" Int 1 BAAAAA== \"invert\" Int 1 AAAAAA== \"constant_transform\" Int 1 AQAAAA== \"angle_between_axis\" Float 3 AAAAAAAAgD8AAAAAAAAAAA== \"angle_convert_from\" Int 1 AAAAAA== \"angleConvertTo\" Int 1 AwAAAA== 27 \"size\" 1 1 \"isolate\" 1 1 \"cat\" 1 1 \"math_op2\" 1 1 \"math_op3\" 1 1 \"trans_op\" 1 1 \"util_op\" 1 1 \"cons\" 1 1 \"val\" 1 1 \"val2\" 2 1 \"val3\" 3 1 \"uni\" 1 1 \"t2\" 2 1 \"t3\" 3 1 \"r2\" 1 1 \"r3\" 3 1 \"ru\" 1 1 \"s2\" 2 1 \"s3\" 3 1 \"us\" 1 1 \"to\" 1 1 \"ro3\" 1 1 \"inv\" 1 1 \"cons_trans\" 1 1 \"ab_axis\" 3 1 \"angConvFrom\" 1 1 \"angConvTo\" 1 1 0"
   kernelSource "#define PI 3.1415926535897932384626433832795028841971693993751058;\n\nfloat degrees(float rad)\{\n  return rad * 180.0 / PI;\n\}\nfloat2 degrees(float2 rad)\{\n  return float2(degrees(rad.x), degrees(rad.y));\n\}\nfloat3 degrees(float3 rad)\{\n  return float3(degrees(rad.x), degrees(rad.y), degrees(rad.z));\n\}\nfloat radians(float deg)\{\n  return deg / 180.0 * PI;\n\}\nfloat2 radians(float2 deg)\{\n  return float2(radians(deg.x), radians(deg.y));\n\}\nfloat3 radians(float3 deg)\{\n  return float3(radians(deg.x), radians(deg.y), radians(deg.z));\n\}\nfloat signedToRad(float signedf)\{\n  return ((signedf/2.0)+0.5) * PI ;\n\}\nfloat radToSigned(float rad)\{\n  rad = rad/ PI;\n  return ((rad-0.5)*2.0);\n\}\nfloat unsignedToRad(float unsignedf)\{\n  return unsignedf * 2.0 * PI;\n\}\nfloat radToUnsigned(float rad)\{\n  return (rad / 2.0) / PI;\n\}\n\nfloat3x3 ident3x3()\{\n  float3x3 mat;\n  mat\[0]\[0] = 1.0;\n  mat\[0]\[1] = 0.0;\n  mat\[0]\[2] = 0.0;\n  mat\[1]\[0] = 0.0;\n  mat\[1]\[1] = 1.0;\n  mat\[1]\[2] = 0.0;\n  mat\[2]\[0] = 0.0;\n  mat\[2]\[1] = 0.0;\n  mat\[2]\[2] = 1.0;\n  return mat;\n\}\nfloat4x4 ident4x4()\{\n  float4x4 mat;\n  mat\[0]\[0] = 1.0;\n  mat\[0]\[1] = 0.0;\n  mat\[0]\[2] = 0.0;\n  mat\[0]\[3] = 0.0;\n  mat\[1]\[0] = 0.0;\n  mat\[1]\[1] = 1.0;\n  mat\[1]\[2] = 0.0;\n  mat\[1]\[3] = 0.0;\n  mat\[2]\[0] = 0.0;\n  mat\[2]\[1] = 0.0;\n  mat\[2]\[2] = 1.0;\n  mat\[2]\[3] = 0.0;\n  mat\[3]\[0] = 0.0;\n  mat\[3]\[1] = 0.0;\n  mat\[3]\[2] = 0.0;\n  mat\[3]\[3] = 1.0;\n  return mat;\n\}\nfloat2 mult(float2 a, float3x3 mat)\{\n  return float2((a.x*mat\[0]\[0])+(a.y*mat\[0]\[1])+mat\[0]\[2],\n                (a.x*mat\[1]\[0])+(a.y*mat\[1]\[1])+mat\[1]\[2]);\n\}\nfloat3 mult(float3 a, float4x4 mat)\{\n  return float3((a.x*mat\[0]\[0])+(a.y*mat\[0]\[1])+(a.z*mat\[0]\[2])+mat\[0]\[3],\n                (a.x*mat\[1]\[0])+(a.y*mat\[1]\[1])+(a.z*mat\[1]\[2])+mat\[1]\[3],\n                (a.x*mat\[2]\[0])+(a.y*mat\[2]\[1])+(a.z*mat\[2]\[2])+mat\[2]\[3]);\n\}\nfloat3x3 translate(float2 t)\{\n  float3x3 mat = ident3x3();\n  mat\[0]\[2] = t.x;\n  mat\[1]\[2] = t.y;\n  return mat;\n\}\nfloat4x4 translate(float3 t)\{\n  float4x4 mat = ident4x4();\n  mat\[0]\[3] = t.x;\n  mat\[1]\[3] = t.y;\n  mat\[2]\[3] = t.z;\n  return mat;\n\}\nfloat3x3 rotate(float angle)\{\n  float3x3 mat = ident3x3();\n  mat\[0]\[0] = cos(angle);\n  mat\[0]\[1] = sin(angle);\n  mat\[1]\[0] = -sin(angle);\n  mat\[1]\[1] = cos(angle);\n  return mat;\n\}\nfloat4x4 rotateAxis(float angle, int axis)\{\n  float4x4 mat = ident4x4();\n  if(axis==0)\{      // X\n    mat\[1]\[1] =  cos(angle);\n    mat\[1]\[2] = -sin(angle);\n    mat\[2]\[1] =  sin(angle);\n    mat\[2]\[2] =  cos(angle);\n  \}else if(axis==1)\{// Y\n    mat\[0]\[0] =  cos(angle);\n    mat\[0]\[2] =  sin(angle);\n    mat\[2]\[0] = -sin(angle);\n    mat\[2]\[2] =  cos(angle);\n  \}else if(axis==2)\{// Z\n    mat\[0]\[0] =  cos(angle);\n    mat\[0]\[1] = -sin(angle);\n    mat\[1]\[0] =  sin(angle);\n    mat\[1]\[1] =  cos(angle);\n  \}\n  return mat;\n\}\nfloat4x4 rotate(float3 angle, int order)\{\n  float4x4 mat = ident4x4();\n  float4x4 x = rotateAxis(angle.x, 0);\n  float4x4 y = rotateAxis(angle.y, 1);\n  float4x4 z = rotateAxis(angle.z, 2);\n  if(order==0)\{       // XYZ\n    mat = z*y*x;\n  \}else  if(order==1)\{// XZY\n    mat = y*z*x;\n  \}else  if(order==2)\{// YXZ\n    mat = z*x*y;\n  \}else  if(order==3)\{// YZX\n    mat = x*z*y;\n  \}else  if(order==4)\{// ZXY\n    mat = y*x*z;\n  \}else  if(order==5)\{// ZYX\n    mat = x*y*z;\n  \}\n  return mat;\n\}\nfloat3x3 scale(float2 s)\{\n  float3x3 mat = ident3x3();\n  mat\[0]\[0] = s.x;\n  mat\[1]\[1] = s.y;\n  return mat;\n\}\nfloat4x4 scale(float3 s)\{\n  float4x4 mat = ident4x4();\n  mat\[0]\[0] = s.x;\n  mat\[1]\[1] = s.y;\n  mat\[2]\[2] = s.z;\n  return mat;\n\}\nfloat3x3 transform(float2 _t, float _r, float2 _s, int order)\{\n  float3x3 m = ident3x3();\n  float3x3 t = translate(_t);\n  float3x3 r = rotate(_r);\n  float3x3 s = scale(_s);\n  if(order==0)\{      // SRT\n    m = t*r*s;\n  \}else if(order==1)\{// STR\n    m = r*t*s;\n  \}else if(order==2)\{// RST\n    m = t*s*r;\n  \}else if(order==3)\{// RTS\n    m = s*t*r;\n  \}else if(order==4)\{// TSR\n    m = r*s*t;\n  \}else if(order==5)\{// TRS\n    m = s*r*t;\n  \}\n  return m;\n\}\nfloat4x4 transform(float3 _t, float3 _r, float3 _s, int order, int rot_order)\{\n  float4x4 m = ident4x4();\n  float4x4 t = translate(_t);\n  float4x4 r = rotate(_r, rot_order);\n  float4x4 s = scale(_s);\n  if(order==0)\{      // SRT\n    m = t*r*s;\n  \}else if(order==1)\{// STR\n    m = r*t*s;\n  \}else if(order==2)\{// RST\n    m = t*s*r;\n  \}else if(order==3)\{// RTS\n    m = s*t*r;\n  \}else if(order==4)\{// TSR\n    m = r*s*t;\n  \}else if(order==5)\{// TRS\n    m = s*r*t;\n  \}\n  return m;\n\}\nfloat3 cross(float3 A, float3 B)\{\n  return float3(A.y*B.z - A.z*B.y,\n                A.z*B.x - A.x*B.z,\n                A.x*B.y - A.y*B.x);\n\}\nfloat distance(float2 a, float2 b)\{\n  return length(a-b);\n\}\nfloat distance(float3 a, float3 b)\{\n  return length(a-b);\n\}\nfloat2 norm(float2 a)\{\n  return a/length(a);\n\}\nfloat3 norm(float3 a)\{\n  return a/length(a);\n\}\nfloat angleBetween(float3 a, float3 b, float3 axis)\{\n  a = norm(a);\n  b = norm(b);\n  axis = norm(axis);\n  float3 perp = norm(cross(b, axis));\n  float side = dot(a, perp);\n  float angle = acos(dot(a, b));\n  if(side<0.0)\{\n    angle = -angle + 2.0 * PI ;\n  \}\n  return angle;\n\}\n\nfloat angleBetween(float2 a, float2 b)\{\n  float dott = a.x*b.x + a.y*b.y;\n  float dett = a.x*b.y - a.y*b.x;\n  float angle = atan2(dett, dott);\n  if(angle<0)\{\n    angle = angle + 2.0 * PI;\n  \}\n  return angle;\n\}\nfloat angleConvert(float angle, int from, int to)\{\n  if(from==0)\{\n    angle = signedToRad(angle);\n  \}else if(from==1)\{\n    angle = unsignedToRad(angle);\n  \}else if(from==3)\{\n    angle = radians(angle);\n  \}\n  if(to==0)\{\n    angle = radToSigned(angle);\n  \}else if(to==1)\{\n    angle = radToUnsigned(angle);\n  \}else if(to==3)\{\n    angle = degrees(angle);\n  \}\n  return angle;\n\}\n\nkernel vector : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // A\n  Image<eRead, eAccessPoint, eEdgeClamped> srcB; // B\n  Image<eWrite> dst; // the output image\n\n  param:\n    int size;\n    int isolate;\n    // op\n    int cat;\n    int math_op2;\n    int math_op3;\n    int trans_op;\n    int util_op;\n\n    int cons;\n    float val;\n    float2 val2;\n    float3 val3;\n    int uni;\n\n    // Transform\n    float2 t2;\n    float3 t3;\n    float r2;\n    float3 r3;\n    int ru;\n    float2 s2;\n    float3 s3;\n    float us;\n    int to;\n    int ro3;\n    int inv;\n    int cons_trans;\n\n    float3 ab_axis;\n    int angConvFrom;\n    int angConvTo;\n\n  void define()\{\n    defineParam(size, \"size\", 1);\n    defineParam(isolate, \"isolate\", 1);\n    // op\n    defineParam(cat, \"category\", 2);//transform\n    defineParam(math_op2, \"math_operation2\", 5);//normalize\n    defineParam(math_op3, \"math_operation3\", 5);//normalize\n    defineParam(trans_op, \"transform_operation\", 3);//transform\n    defineParam(util_op, \"utility_operation\", 0);//distance\n\n    defineParam(cons, \"constant\", int(1));\n    defineParam(val3, \"value3\", float3(0,0,0));\n    defineParam(val2, \"value2\", float2(0,0));\n    defineParam(val, \"value\", float(0));\n    defineParam(uni, \"uniform\", int(0));\n\n    // Transform\n    defineParam(cons_trans, \"constant_transform\", int(1));\n    defineParam(t2, \"translate2\", float2(0,0));\n    defineParam(t3, \"translate3\", float3(0,0,0));\n    defineParam(r2, \"rotate\", float(0));\n    defineParam(r3, \"rotate3\", float3(0,0,0));\n    defineParam(ru, \"rotateunit\", int(0));\n    defineParam(s2, \"scale2\", float2(1,1));\n    defineParam(s3, \"scale3\", float3(1,1,1));\n    defineParam(us, \"uniformScale\", float(1.0));\n    defineParam(to, \"transform_order\", 0);\n    defineParam(ro3, \"rotate_order3\", 4);\n    defineParam(inv, \"invert\", int(0));\n\n    defineParam(ab_axis, \"angle_between_axis\", float3(0,1,0));\n    defineParam(angConvFrom, \"angle_convert_from\", int(0));\n    defineParam(angConvTo, \"angleConvertTo\", int(3));\n\n  \}\n\n  void process() \{\n    float4 colA = src();\n    float4 colB = srcB();\n    if(isolate==1)\{\n      if(size==0)\{\n        colA.z = 0.0;\n      \}\n      //colA.w = 0.0;\n    \}\n\n    if(size==0)\{\n      // VECTOR 2\n      float2 A2 = float2(colA.x, colA.y);\n      if(cons==0)\{\n        val2 = float2(colB.x, colB.y);\n      \}else if(uni==1)\{\n        val2 = float2(val, val);\n      \}\n      if(cat==0)\{\n        // Initialize\n        A2 = val2;\n      \}else if(cat==1)\{\n        // Math\n        if(math_op2==0)\{\n          A2 += val2;\n        \}else if(math_op2==1)\{\n          A2 -= val2;\n        \}else if(math_op2==2)\{\n          A2 *= val2;\n        \}else if(math_op2==3)\{\n          A2 /= val2;\n        \}else if(math_op2==4)\{\n          A2 = fmod(A2, val2);\n        \}else if(math_op2==5)\{\n          A2 = norm(A2);\n        \}else if(math_op2==6)\{\n          float i = length(A2);\n          A2 = float2(i,i);\n        \}else if(math_op2==7)\{\n          float i = dot(A2, val2);\n          A2 = float2(i,i);\n        \}\n      \}else if(cat==2)\{\n        // Transform\n        float2 t = t2;\n        float r = r2;\n        float2 s = s2*us;\n        float3x3 m;\n        if(cons_trans==0 && trans_op!=3)\{\n          t = float2(colB.x, colB.y);\n          r = colB.x;\n          s = float2(colB.x, colB.y);\n        \}\n        if(ru==0)\{\n          r = radians(r);\n        \}\n        if(trans_op==0)\{\n          m = translate(t);\n        \}else if(trans_op==1)\{\n          m = rotate(r);\n        \}else if(trans_op==2)\{\n          m = scale(s);\n        \}else if(trans_op==3)\{\n          m = transform(t, r, s, to);\n        \}\n        if(inv==1)\{\n          m = m.invert();\n        \}\n        A2 = mult(A2, m);\n      \}else if(cat==3)\{\n        // Utility\n        if(util_op==0)\{\n          float i = distance(A2, val2);\n          A2 = float2(i,i);\n        \}else if(util_op==1)\{\n          float i = angleBetween(A2, val2);\n          A2 = float2(i,i);\n        \}else if(util_op==2)\{\n          float i = angleConvert(A2.x, angConvFrom, angConvTo);\n          A2 = float2(i,i);\n        \}\n      \}\n      dst() = float4(A2.x, A2.y, colA.z, colA.w);\n    \}else if(size==1)\{\n      // VECTOR 3\n      float3 A3 = float3(colA.x, colA.y, colA.z);\n      if(cons==0)\{\n        val3 = float3(colB.x, colB.y, colB.z);\n      \}else if(uni==1)\{\n        val3 = float3(val, val, val);\n      \}\n      if(cat==0)\{\n        // Initialize\n        A3 = val3;\n      \}else if(cat==1)\{\n        // Math\n        if(math_op3==0)\{\n          A3 += val3;\n        \}else if(math_op3==1)\{\n          A3 -= val3;\n        \}else if(math_op3==2)\{\n          A3 *= val3;\n        \}else if(math_op3==3)\{\n          A3 /= val3;\n        \}else if(math_op3==4)\{\n          A3 = fmod(A3, val3);\n        \}else if(math_op3==5)\{\n          A3 = norm(A3);\n        \}else if(math_op3==6)\{\n          float i = length(A3);\n          A3 = float3(i,i,i);\n        \}else if(math_op3==7)\{\n          float i = dot(A3, val3);\n          A3 = float3(i,i,i);\n        \}else if(math_op3==8)\{\n          A3 = cross(A3, val3);\n        \}\n      \}else if(cat==2)\{\n        // Transform\n        float3 t = t3;\n        float3 r = r3;\n        float3 s = s3*us;\n        if(cons_trans==0 && trans_op!=3)\{\n          t = float3(colB.x, colB.y, colB.z);\n          r = float3(colB.x, colB.y, colB.z);\n          s = float3(colB.x, colB.y, colB.z);\n        \}\n        float4x4 m;\n        if(ru==0)\{\n          r = radians(r);\n        \}\n        if(trans_op==0)\{\n          m = translate(t);\n        \}else if(trans_op==1)\{\n          m = rotate(r, ro3);\n        \}else if(trans_op==2)\{\n          m = scale(s);\n        \}else if(trans_op==3)\{\n          m = transform(t, r, s, to, ro3);\n        \}\n        if(inv==1)\{\n          m = m.invert();\n        \}\n        A3 = mult(A3, m);\n      \}else if(cat==3)\{\n        // Utility\n        if(util_op==0)\{\n          float i = distance(A3, val3);\n          A3 = float3(i,i,i);\n        \}else if(util_op==1)\{\n          float i = angleBetween(A3, val3, ab_axis);\n          A3 = float3(i,i,i);\n        \}else if(util_op==2)\{\n          float i = angleConvert(A3.x, angConvFrom, angConvTo);\n          A3 = float3(i,i,i);\n        \}\n      \}\n      dst() = float4(A3.x, A3.y, A3.z, colA.w);\n    \}\n  \}\n\};\n"
   rebuild ""
   vector_size {{parent.size}}
   vector_isolate {{parent.isolate}}
   vector_category {{parent.category}}
   vector_math_operation2 {{parent.math_op2}}
   vector_math_operation3 {{parent.math_op3}}
   vector_transform_operation {{parent.transform_op}}
   vector_utility_operation {{parent.utility_op}}
   vector_constant {{parent.constant}}
   vector_value {{parent.value}}
   vector_value2 {{parent.value2} {parent.value2}}
   vector_value3 {{parent.value3} {parent.value3} {parent.value3}}
   vector_uniform {{parent.uniform}}
   vector_translate2 {{parent.translate2} {parent.translate2}}
   vector_translate3 {{parent.translate3} {parent.translate3} {parent.translate3}}
   vector_rotate {{parent.rotate}}
   vector_rotate3 {{parent.rotate3} {parent.rotate3} {parent.rotate3}}
   vector_rotateunit {{parent.rotateunit}}
   vector_scale2 {{parent.scale2} {parent.scale2}}
   vector_scale3 {{parent.scale3} {parent.scale3} {parent.scale3}}
   vector_uniformScale {{parent.uniformScale}}
   vector_transform_order {{parent.transform_order}}
   vector_rotate_order3 {{parent.rotation_order3}}
   vector_invert {{parent.invert}}
   vector_constant_transform {{parent.constant_trans}}
   vector_angle_between_axis {{parent.angleBetweenAxis} {parent.angleBetweenAxis} {parent.angleBetweenAxis}}
   vector_angle_convert_from {{parent.angleConvertFrom}}
   vector_angleConvertTo {{parent.angleConvertTo}}
   rebuild_finalise ""
   name BlinkScript3
   selected true
   xpos 256
   ypos 242
  }
  Output {
   name Output1
   xpos 256
   ypos 321
  }
 end_group
 Expression {
  channel0 rgba
  expr0 r<0.000001?0:1
  name Expression6
  label Alpha
  xpos 228
  ypos 160
 }
 Dot {
  name Dot11
  xpos 262
  ypos 300
 }
push $N55b2bc00
 Shuffle {
  in {{{ViewSpaceP.vectorIn.in}}}
  name Shuffle2
  label "ViewSpace\nPosition"
  xpos 0
  ypos 198
  postage_stamp true
 }
set N470bc380 [stack 0]
 Merge2 {
  inputs 2
  operation multiply
  Achannels {rgba.red rgba.green rgba.blue -rgba.alpha}
  Bchannels {rgba.red rgba.green rgba.blue -rgba.alpha}
  output {rgba.red rgba.green rgba.blue -rgba.alpha}
  name Merge2
  xpos 0
  ypos 296
 }
 BlinkScript {
  inputs 4
  recompileCount 164
  ProgramGroup 1
  KernelDescription "2 \"SSAO\" iterate pixelWise 7ff5cc1f984b55f2ad2988a5ae96e9f004eb5c1da4e1b232078dbc96d19b92d6 5 \"inViewSpaceP\" Read Random \"inViewSpaceN\" Read Point \"inSamples\" Read Random \"inRandRots\" Read Random \"dst\" Write Point 8 \"samples\" Int 1 AAAAAA== \"rotations\" Int 1 AAAAAA== \"radius\" Float 1 AAAAAA== \"bias\" Float 1 AAAAAA== \"width\" Int 1 AAAAAA== \"height\" Int 1 AAAAAA== \"focal\" Float 1 AAAAAA== \"haperture\" Float 1 AAAAAA== 8 \"samples\" 1 1 \"rotations\" 1 1 \"radius\" 1 1 \"bias\" 1 1 \"width\" 1 1 \"height\" 1 1 \"focal\" 1 1 \"haperture\" 1 1 2 \"aspect\" Float 1 1 AAAAAA== \"projection\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "// 2021-08-25\n// Made by Mathieu Goulet-Aubin\n// email: mathieugouletaubin@gmail.com\n// Based on OpenGL SSAO lesson https://learnopengl.com/Advanced-Lighting/SSAO\n\nfloat4 color(float3 vector)\{\n    return float4(vector.x, vector.y, vector.z, 0);\n\}\nfloat4 color(float3 vector, float a)\{\n    return float4(vector.x, vector.y, vector.z, a);\n\}\nfloat3 vector(float4 color)\{\n    return float3(color.x, color.y, color.z);\n\}\nfloat3 norm(float3 a)\{\n  return a/length(a);\n\}\nfloat smoothstep(float edge0, float edge1, float x) \{\n  // Scale, bias and saturate x to 0..1 range\n  x = clamp((x - edge0) / (edge1 - edge0), 0.0f, 1.0f); \n  // Evaluate polynomial\n  return x * x * (3 - 2 * x);\n\}\nfloat4x4 matrix4x4(float3 tangent, float3 bitangent, float3 normal)\{\n  // Creates a matrix from frame vectors\n  float4x4 mat;\n  mat\[0]\[0] = tangent.x;\n  mat\[0]\[1] = tangent.y;\n  mat\[0]\[2] = tangent.z;\n  mat\[0]\[3] = 0.0;\n  mat\[1]\[0] = bitangent.x;\n  mat\[1]\[1] = bitangent.y;\n  mat\[1]\[2] = bitangent.z;\n  mat\[1]\[3] = 0.0;\n  mat\[2]\[0] = normal.x;\n  mat\[2]\[1] = normal.y;\n  mat\[2]\[2] = normal.z;\n  mat\[2]\[3] = 0.0;\n  mat\[3]\[0] = 0.0;\n  mat\[3]\[1] = 0.0;\n  mat\[3]\[2] = 0.0;\n  mat\[3]\[3] = 1.0;\n  return mat.invert();\n\}\nfloat3 mult(float3 a, float4x4 mat)\{\n  return float3((a.x*mat\[0]\[0])+(a.y*mat\[0]\[1])+(a.z*mat\[0]\[2])+mat\[0]\[3],\n                (a.x*mat\[1]\[0])+(a.y*mat\[1]\[1])+(a.z*mat\[1]\[2])+mat\[1]\[3],\n                (a.x*mat\[2]\[0])+(a.y*mat\[2]\[1])+(a.z*mat\[2]\[2])+mat\[2]\[3]);\n\}\nfloat4 mult(float4 a, float4x4 mat)\{\n  return float4((a.x*mat\[0]\[0])+(a.y*mat\[0]\[1])+(a.z*mat\[0]\[2])+mat\[0]\[3],\n                (a.x*mat\[1]\[0])+(a.y*mat\[1]\[1])+(a.z*mat\[1]\[2])+mat\[1]\[3],\n                (a.x*mat\[2]\[0])+(a.y*mat\[2]\[1])+(a.z*mat\[2]\[2])+mat\[2]\[3],\n                (a.x*mat\[3]\[0])+(a.y*mat\[3]\[1])+(a.z*mat\[3]\[2])+mat\[3]\[3]);\n\}\nfloat angleOfView(float aperture, float focalLength)\{\n  return 2.0f * atan( 0.5f * aperture / focalLength);\n\}\nfloat4x4 projectionMatrix(float aov, float aspect)\{\n  float4x4 M;\n  // X\n  M\[0]\[0] = 1.0f / (aspect * tan(aov / 2.0f));\n  M\[0]\[1] = 0.0;\n  M\[0]\[2] = 0.0;\n  M\[0]\[3] = 0.0;\n  // Y\n  M\[1]\[0] = 0.0;\n  M\[1]\[1] = 1.0f / tan(aov / 2.0f);\n  M\[1]\[2] = 0.0;\n  M\[1]\[3] = 0.0;\n  // Z\n  M\[2]\[0] = 0.0;\n  M\[2]\[1] = 0.0;\n  M\[2]\[2] = 1.0;\n  M\[2]\[3] = 0.0;\n  // Offset\n  M\[3]\[0] = 0.0;\n  M\[3]\[1] = 0.0;\n  M\[3]\[2] = -1.0;\n  M\[3]\[3] = 0.0;\n  return M;\n\}\n\nfloat3 viewToNDC(float3 point, float4x4 projectionMatrix)\{\n  /*\n  Applies a projection matrix to a point.\n  Components XY end up between 0-1\n  Component Z stays the same\n  */\n  float4 point4 = color(point, 1);\n  point4 = mult(point4, projectionMatrix);\n  float3 point3 = vector(point4) / float3(point4.w, point4.w, 1);\n  return point3 * float3(0.5, 0.5, 1.0) + float3(0.5, 0.5, 0);\n\}\n\n\nkernel SSAO : ImageComputationKernel<ePixelWise>\n\{\n  // Sources\n  Image<eRead, eAccessRandom, eEdgeClamped> inViewSpaceP;\n  Image<eRead, eAccessPoint, eEdgeClamped> inViewSpaceN;\n  Image<eRead, eAccessRandom, eEdgeClamped> inSamples;\n  Image<eRead, eAccessRandom, eEdgeClamped> inRandRots;\n  Image<eWrite> dst;\n\n  param:\n      // Sampling\n      int samples;\n      int rotations;\n      float radius;\n      float bias;\n      // Camera\n      int width;\n      int height;\n      float focal;\n      float haperture;\n\n  local:\n      // Camera\n      float aspect;\n      float4x4 projection;\n\n  void init() \{\n    // Camera\n    aspect = float(width) / float(height);\n    float aov = angleOfView(haperture, focal * aspect);\n    projection = projectionMatrix(aov, aspect);\n      \n  \}\n\n  void process(int2 pos) \{\n    // Samples\n    SampleType(inViewSpaceP) Pcolor = inViewSpaceP(pos.x, pos.y);\n    float3 viewPos = vector(Pcolor);\n    SampleType(inViewSpaceN) Ncolor = inViewSpaceN();\n    float3 normal = norm(vector(Ncolor));\n    SampleType(inRandRots) inRandRotsColor = inRandRots(fmod(pos.x, rotations), fmod(pos.y, rotations));\n    float3 randRot = vector(inRandRotsColor);\n\n    // Matrix from tangentSpace to ViewSpace\n    float3 tangent   = norm(randRot - normal * dot(randRot, normal));\n    float3 bitangent = cross(normal, tangent);\n    float4x4 TBN = matrix4x4(tangent, bitangent, normal);\n\n    // Out of loop declarations\n    SampleType(inSamples) inSamplesColor;\n    SampleType(inViewSpaceP) viewHemiProjPosColor;\n    float occlusion = 0.0;\n    float rangeCheck = 1.0f;\n    float infinityCheck = 1.0f;\n    float3 tangentHemi;\n    float3 viewHemi;\n    float3 hemiP;\n    float3 samplePos;\n    float3 viewHemiPos;\n    float3 ndcHemiPos;\n    float3 viewHemiProjPos;\n    int2 rasterHemiPos;\n\n    for(int i = 0; i < samples; ++i) // Loop over Hemisphere samples\n    \{\n      // Get ScreenSpace position of hemisphere sample\n      inSamplesColor = inSamples(i, 0);\n      tangentHemi = vector(inSamplesColor); // Hemisphere sample\n      viewHemi = mult(tangentHemi, TBN); // from tangent to viewSpace\n      viewHemiPos = viewPos + viewHemi * radius; // Add Hemisphere sample to Position\n      ndcHemiPos = viewToNDC(viewHemiPos, projection); // viewSpace to NDC\n\n      // Get the position overlaping in screenSpace the hemisphere sample position\n      rasterHemiPos.x = width * ndcHemiPos.x;\n      rasterHemiPos.y = height * ndcHemiPos.y;\n      viewHemiProjPosColor = inViewSpaceP(rasterHemiPos.x, rasterHemiPos.y);\n      viewHemiProjPos = vector(viewHemiProjPosColor);\n\n      // Occlude if projected position is closer to camera than the hemisphere sample\n      if(viewHemiProjPos.z >= viewHemiPos.z + bias)\{\n        rangeCheck = smoothstep(0.0, 1.0, radius / fabs(viewHemiPos.z - viewHemiProjPos.z)); // Disregard if too far\n        if( length(viewHemiProjPos) < 0.000001f )\{ // Disregard infinity\n          infinityCheck = 0.0f;\n        \}else\{\n          infinityCheck = 1.0f;\n        \}\n        occlusion += 1.0 * rangeCheck * infinityCheck;\n      \}\n    \} \n    occlusion = 1.0f - (occlusion / float(samples)); // Normalize\n    dst() = occlusion;\n  \}\n\};\n"
  rebuild ""
  SSAO_samples {{parent.samples}}
  SSAO_rotations 64
  SSAO_radius {{parent.radius}}
  SSAO_bias {{parent.threshold}}
  SSAO_width {{width}}
  SSAO_height {{height}}
  SSAO_focal {{"\[topnode parent.input1].focal"}}
  SSAO_haperture {{"\[topnode parent.input1].haperture"}}
  rebuild_finalise ""
  name BlinkScript2
  xpos 0
  ypos 351
 }
set N24bffc00 [stack 0]
 Reformat {
  type scale
  resize none
  center false
  name Reformat3
  xpos 0
  ypos 389
 }
 Invert {
  name Invert2
  xpos 0
  ypos 477
 }
 Grade {
  multiply {{parent.intensity}}
  name Grade7
  xpos 0
  ypos 515
 }
 SoftClip {
  conversion "logarithmic compress"
  softclip_min {{parent.soften}}
  softclip_max {{parent.maxocc}}
  name SoftClip1
  xpos 0
  ypos 541
 }
 Invert {
  name Invert3
  xpos 0
  ypos 567
 }
 Output {
  name Output1
  xpos 0
  ypos 630
 }
push $N67f70e00
 Expression {
  expr0 random(x+(y*height)+(parent.seed*width*height))
  expr1 random((parent.seed*height*width)+(width*height)+y+(x*width))
  expr2 0
  name Expression1
  label "Random\nTangent\nRotations"
  xpos 695
  ypos 185
 }
 Grade {
  channels {rgba.red rgba.green -rgba.blue none}
  multiply 2
  add -1
  black_clamp false
  name Grade1
  xpos 695
  ypos 254
 }
 Expression {
  expr0 0.1
  expr1 0.2
  expr2 0
  name Expression4
  label "Constant\ntangent"
  xpos 695
  ypos 280
  disable {{parent.randomize}}
 }
push $N24bffc00
push $N470bc380
push 0
 Viewer {
  inputs 3
  frame_range 1-100
  input_number 2
  viewerProcess None
  name Viewer1
  xpos 110
  ypos 38
 }
end_group
