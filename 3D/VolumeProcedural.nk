Group {
 name VolumeProcedural2
 selected true
 addUserKnob {20 Volume l VolumeProcedural}
 addUserKnob {26 Occlusion l "Occlusion            "}
 addUserKnob {4 occlusionMode l mode t "Channel used to occlude the volume.\nAnti-aliased pixels work best.\nPositive distance from camera is expected for depth.\nBoth depth and position give the same results.\n" M {depth position none "" "" "" "" ""}}
 addUserKnob {41 occlusionChannel l channel t "Position is expected in the first three components of the channel. Usually (rgb)\nDepth is expected in the first component of the channel. Usually (r) or (Z)" T pos.in}
 addUserKnob {6 unpremultChannel l unpremult t "Avoids fringing issues on alpha edges for antialiased channels.\nUses the alpha of the rgba channel." +STARTLINE}
 unpremultChannel true
 addUserKnob {6 zeroIsInfinity l "zero is infinity" t "Replace zero values with infinity.\nThis avoids the volume being cut where there is no values in the channel." +STARTLINE}
 zeroIsInfinity true
 addUserKnob {26 Shape_div l "Shape                 "}
 addUserKnob {4 shapeType M {Sphere Box Ramp ""}}
 shapeType Ramp
 addUserKnob {12 centerPoint}
 addUserKnob {41 translate T Shape.translate}
 addUserKnob {41 rotate T Shape.rotate}
 addUserKnob {41 scaling l scale T Shape.scaling}
 addUserKnob {41 uniform_scale l "uniform scale" T Shape.uniform_scale}
 addUserKnob {26 VolumeDiv l "Volume               "}
 addUserKnob {18 color}
 color {1 1 1}
 addUserKnob {6 color_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 density}
 density 1
 addUserKnob {6 normalize_density t "Divides the density by the scale of the shape." +STARTLINE}
 normalize_density true
 addUserKnob {26 quality_div l "Quality                "}
 addUserKnob {7 stepSize t "Bigger = Faster / Lower quality\nSmaller = Slower / Higher quality\nThe volume will be sampled every stepSize along the ray projected from the camera.\nStepSize is in world space which makes it influenced by the scene scale."}
 stepSize 0.5
 addUserKnob {20 NoiseTab l Noise}
 addUserKnob {26 NoiseDensityDiv l "Density           "}
 addUserKnob {6 hasDensityNoise l "density noise" +STARTLINE}
 hasDensityNoise true
 addUserKnob {3 densityNoiseOctaves l octaves}
 densityNoiseOctaves 8
 addUserKnob {7 densityNoiseGain l gain}
 densityNoiseGain 0.5
 addUserKnob {7 densityNoiseTime l time}
 addUserKnob {26 ""}
 addUserKnob {41 translate_1 l translate T DensityNoise.translate}
 addUserKnob {41 rotate_1 l rotate T DensityNoise.rotate}
 addUserKnob {41 scaling_1 l scale T DensityNoise.scaling}
 addUserKnob {41 uniform_scale_1 l "uniform scale" T DensityNoise.uniform_scale}
 addUserKnob {6 isDensityNoiseWorldSpace l "world space" +STARTLINE}
 isDensityNoiseWorldSpace true
 addUserKnob {20 AdvancedTab l Advanced}
 addUserKnob {26 AdvancedQualityDiv l "Quality                "}
 addUserKnob {3 stepMin t "The ray takes at least this amount of samples unitl it reaches a collider. It mostly increases the sampling of foreground without affecting the background."}
 stepMin 100
 addUserKnob {3 stepMax t "The ray will stop after this many samples even if there is more volume further along the ray. Values too high can make things slow. "}
 stepMax 1000
 addUserKnob {3 stepsToRefine t "Will increase the samples in the steps closer to the collider.\nThis avoids banding without being too costly."}
 stepsToRefine 1
 addUserKnob {3 stepRefineAmount t "Muliplies the samples by this amount in the refine steps."}
 stepRefineAmount 10
}
 Axis2 {
  inputs 0
  name Shape
  xpos 149
  ypos 298
 }
 Axis2 {
  inputs 0
  name DensityNoise
  xpos 13
  ypos 363
 }
 Input {
  inputs 0
  name cam
  xpos 546
  ypos 278
  number 1
 }
set Nab9e6d0 [stack 0]
 Axis2 {
  useMatrix true
  matrix {
      {{parent.input1.world_matrix} {parent.input1.world_matrix} {parent.input1.world_matrix} {parent.input1.world_matrix}}
      {{parent.input1.world_matrix} {parent.input1.world_matrix} {parent.input1.world_matrix} {parent.input1.world_matrix}}
      {{parent.input1.world_matrix} {parent.input1.world_matrix} {parent.input1.world_matrix} {parent.input1.world_matrix}}
      {{parent.input1.world_matrix} {parent.input1.world_matrix} {parent.input1.world_matrix} {parent.input1.world_matrix}}
    }
  name camera_transform
  xpos 679
  ypos 317
 }
push $Nab9e6d0
 NoOp {
  name AngleOfView
  xpos 546
  ypos 338
  addUserKnob {20 User}
  addUserKnob {7 horizontal}
  horizontal {{2*degrees(atan(parent.input1.haperture/(2*parent.input1.focal)))}}
  addUserKnob {7 vertical}
  vertical {{2*degrees(atan(parent.input1.vaperture/(2*parent.input1.focal)))}}
 }
 Input {
  inputs 0
  name Input
  xpos 323
  ypos 259
 }
 Shuffle {
  in other
  in2 alpha
  alpha red2
  name pos
  xpos 323
  ypos 310
 }
 Unpremult {
  name Unpremult1
  xpos 323
  ypos 336
  disable {{!parent.unpremultChannel}}
 }
 BlinkScript {
  recompileCount 544
  ProgramGroup 1
  KernelDescription "2 \"P_vol\" iterate pixelWise eea9c1b3efb3281ca7cc330195b0c547126dae762b9ca62f6b311cecea9df398 2 \"src\" Read Point \"dst\" Write Point 25 \"occlusionMode\" Int 1 AAAAAA== \"shapeType\" Int 1 AAAAAA== \"shapeTransformMatrix\" Float 16 YHeU4Kd/AABZAAAAAAAAAGB3lOCnfwAAAQAAAAAAAADwrtTs/n8AAAIAAAAAAAAABi/5y6d/AAAAAAAAAAAAAA== \"color\" Float 3 AACAPwAAgD8AAIA/AAAAAA== \"densityMultiplier\" Float 1 AACAPw== \"stepSize\" Float 1 zczMPQ== \"stepMin\" Int 1 ZAAAAA== \"stepMax\" Int 1 oIYBAA== \"stepsToRefine\" Int 1 AgAAAA== \"stepRefineAmount\" Int 1 CgAAAA== \"isDensityNormalized\" Int 1 AQAAAA== \"isZeroAsInfinity\" Int 1 AQAAAA== \"cameraTransformMatrix\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"angleOfView\" Float 2 AAAAAAAAAAA= \"imageSize\" Int 2 AAAAAAAAAAA= \"hasDensityNoise\" Int 1 AAAAAA== \"densityNoiseOctaves\" Int 1 CAAAAA== \"densityNoiseGain\" Float 1 AAAAPw== \"densityNoiseTime\" Float 1 AAAAAA== \"densityNoiseTransformMatrix\" Float 16 AQAAAAAAAAA5AAAAXAAAAICt1Oz+fwAAAAAAAAAAAAAAAAAAAAAAAG4AAAB3AAAAAAAAAAAAAAB/rdTs/n8AAA== \"isdensityNoiseWorldSpace\" Int 1 AQAAAA== \"densityNoiseFit0\" Float 1 AAAAAA== \"densityNoiseFit1\" Float 1 AACAPw== \"densityNoiseBias\" Float 1 AAAAAA== \"densityNoiseClamp\" Float 1 AAAAAA== 25 \"occlusionMode\" 1 1 \"shapeType\" 1 1 \"shapeTransformMatrix\" 16 1 \"color\" 3 1 \"densityMultiplier\" 1 1 \"stepSizeUser\" 1 1 \"stepMin\" 1 1 \"stepMax\" 1 1 \"stepsToRefine\" 1 1 \"stepRefineAmount\" 1 1 \"isDensityNormalized\" 1 1 \"isZeroAsInfinity\" 1 1 \"cameraTransformMatrix\" 16 1 \"angleOfView\" 2 1 \"imageSize\" 2 1 \"hasDensityNoise\" 1 1 \"densityNoiseOctaves\" 1 1 \"densityNoiseGain\" 1 1 \"densityNoiseTime\" 1 1 \"densityNoiseTransformMatrix\" 16 1 \"isdensityNoiseWorldSpace\" 1 1 \"densityNoiseFit0\" 1 1 \"densityNoiseFit1\" 1 1 \"densityNoiseBias\" 1 1 \"densityNoiseClamp\" 1 1 4 \"infinity\" Float 1 1 AAAAAA== \"rayOrigin\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"shapeTransformMatrixInverted\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"densityNoiseTransformMatrixInverted\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "/*\nSIMPLEX NOISE\nBased on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\nPorted by Mads Hagbarth Lund 2014\n*/\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\nfloat raw_noise_4d( const float x, const float y, const float z, const float w )\{\n  int simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n  \};\n  int perm\[512] = \{\n    151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n    8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n    35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n    134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n    55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n    18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n    250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n    189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n    172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n    228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n    107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n    151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n    8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n    35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n    134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n    55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n    18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n    250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n    189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n    172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n    228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n    107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n  \};\n  int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n  \};\n  float F4 = (sqrt(5.0f)-1.0)/4.0;\n  float G4 = (5.0-sqrt(5.0f))/20.0;\n  float n0, n1, n2, n3, n4;\n  float s = (x + y + z + w) * F4;\n  int i = fastfloor(x + s);\n  int j = fastfloor(y + s);\n  int k = fastfloor(z + s);\n  int l = fastfloor(w + s);\n  float t = (i + j + k + l) * G4;\n  float X0 = i - t;\n  float Y0 = j - t;\n  float Z0 = k - t;\n  float W0 = l - t;\n\n  float x0 = x - X0;\n  float y0 = y - Y0;\n  float z0 = z - Z0;\n  float w0 = w - W0;\n  int c1 = (x0 > y0) ? 32 : 0;\n  int c2 = (x0 > z0) ? 16 : 0;\n  int c3 = (y0 > z0) ? 8 : 0;\n  int c4 = (x0 > w0) ? 4 : 0;\n  int c5 = (y0 > w0) ? 2 : 0;\n  int c6 = (z0 > w0) ? 1 : 0;\n  int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n  int i1, j1, k1, l1;\n  int i2, j2, k2, l2;\n  int i3, j3, k3, l3;\n  i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n  j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n  k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n  l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n  i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n  j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n  k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n  l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n  i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n  j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n  k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n  l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n  float x1 = x0 - i1 + G4;\n  float y1 = y0 - j1 + G4;\n  float z1 = z0 - k1 + G4;\n  float w1 = w0 - l1 + G4;\n  float x2 = x0 - i2 + 2.0*G4;\n  float y2 = y0 - j2 + 2.0*G4;\n  float z2 = z0 - k2 + 2.0*G4;\n  float w2 = w0 - l2 + 2.0*G4;\n  float x3 = x0 - i3 + 3.0*G4;\n  float y3 = y0 - j3 + 3.0*G4;\n  float z3 = z0 - k3 + 3.0*G4;\n  float w3 = w0 - l3 + 3.0*G4;\n  float x4 = x0 - 1.0 + 4.0*G4;\n  float y4 = y0 - 1.0 + 4.0*G4;\n  float z4 = z0 - 1.0 + 4.0*G4;\n  float w4 = w0 - 1.0 + 4.0*G4;\n  int ii = i & 255;\n  int jj = j & 255;\n  int kk = k & 255;\n  int ll = l & 255;\n  int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n  int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n  int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n  int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n  int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n  float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n  if(t0<0) n0 = 0.0;\n  else \{\n      t0 *= t0;\n      n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n  \}\n  float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n  if(t1<0) n1 = 0.0;\n  else \{\n      t1 *= t1;\n      n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n  \}\n  float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n  if(t2<0) n2 = 0.0;\n  else \{\n      t2 *= t2;\n      n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n  \}\n  float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n  if(t3<0) n3 = 0.0;\n  else \{\n      t3 *= t3;\n      n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n  \}\n  float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n  if(t4<0) n4 = 0.0;\n  else \{\n      t4 *= t4;\n      n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n  \}\n  return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\nfloat octave_noise_4d( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w )\{\n  float total = 0;\n  float frequency = scale;\n  float amplitude = 1;\n  float maxAmplitude = 0;\n  for( int i=0; i < octaves; i++ ) \{\n      total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n\n      frequency *= 2;\n      maxAmplitude += amplitude;\n      amplitude *= persistence;\n  \}\n  return float(total / maxAmplitude);\n\}\n/*\nEND SIMPLEX NOISE\n*/\n\n\n#define PI 3.1415926535897932384626433832795028841971693993751058;\n\nfloat radians(float deg)\{\n  return deg / 180.0 * PI;\n\}\n\ninline float3 norm(float3 a)\{\n  return a/length(a);\n\}\n\nfloat4x4 ident4x4()\{\n  float4x4 mat;\n  mat\[0]\[0] = 1.0;\n  mat\[0]\[1] = 0.0;\n  mat\[0]\[2] = 0.0;\n  mat\[0]\[3] = 0.0;\n  mat\[1]\[0] = 0.0;\n  mat\[1]\[1] = 1.0;\n  mat\[1]\[2] = 0.0;\n  mat\[1]\[3] = 0.0;\n  mat\[2]\[0] = 0.0;\n  mat\[2]\[1] = 0.0;\n  mat\[2]\[2] = 1.0;\n  mat\[2]\[3] = 0.0;\n  mat\[3]\[0] = 0.0;\n  mat\[3]\[1] = 0.0;\n  mat\[3]\[2] = 0.0;\n  mat\[3]\[3] = 1.0;\n  return mat;\n\}\nfloat4x4 rotateAxis(float angle, int axis)\{\n  float4x4 mat = ident4x4();\n  if(axis==0)\{      // X\n    mat\[1]\[1] =  cos(angle);\n    mat\[1]\[2] = -sin(angle);\n    mat\[2]\[1] =  sin(angle);\n    mat\[2]\[2] =  cos(angle);\n  \}else if(axis==1)\{// Y\n    mat\[0]\[0] =  cos(angle);\n    mat\[0]\[2] =  sin(angle);\n    mat\[2]\[0] = -sin(angle);\n    mat\[2]\[2] =  cos(angle);\n  \}else if(axis==2)\{// Z\n    mat\[0]\[0] =  cos(angle);\n    mat\[0]\[1] = -sin(angle);\n    mat\[1]\[0] =  sin(angle);\n    mat\[1]\[1] =  cos(angle);\n  \}\n  return mat;\n\}\nfloat4x4 rotate(float3 angle, int order)\{\n  float4x4 mat = ident4x4();\n  float4x4 x = rotateAxis(angle.x, 0);\n  float4x4 y = rotateAxis(angle.y, 1);\n  float4x4 z = rotateAxis(angle.z, 2);\n  if(order==0)\{       // XYZ\n    mat = z*y*x;\n  \}else  if(order==1)\{// XZY\n    mat = y*z*x;\n  \}else  if(order==2)\{// YXZ\n    mat = z*x*y;\n  \}else  if(order==3)\{// YZX\n    mat = x*z*y;\n  \}else  if(order==4)\{// ZXY\n    mat = y*x*z;\n  \}else  if(order==5)\{// ZYX\n    mat = x*y*z;\n  \}\n  return mat;\n\}\nfloat3 mult(float3 a, float4x4 mat)\{\n  return float3((a.x*mat\[0]\[0])+(a.y*mat\[0]\[1])+(a.z*mat\[0]\[2])+mat\[0]\[3],\n                (a.x*mat\[1]\[0])+(a.y*mat\[1]\[1])+(a.z*mat\[1]\[2])+mat\[1]\[3],\n                (a.x*mat\[2]\[0])+(a.y*mat\[2]\[1])+(a.z*mat\[2]\[2])+mat\[2]\[3]);\n\}\n\nfloat3 projectPointOnLine(float3 linePoint1, float3 linePoint2, float3 point)\{\n  float3 lineDirection = norm(linePoint2-linePoint1);\n  float t = dot(point - linePoint1, lineDirection);\n  return linePoint1 + lineDirection * t;\n\}\nfloat3 projectPointOnLineSegment(float3 linePoint1, float3 linePoint2, float3 point)\{\n  float3 pointProjectedOnLine = projectPointOnLine(linePoint1, linePoint2 - linePoint1, point);\n  float3 v = linePoint2 - linePoint1;\n  return linePoint1 + v * clamp(dot(v, (point - linePoint1) / dot(v,v)), 0.0f, 1.0f);\n\}\nint isIntersectingLineUnitSphere(float3 linePoint1, float3 linePoint2)\{\n  float3 segmentCenter = projectPointOnLine(linePoint1, linePoint2, float3(0.0f));\n  if(length(segmentCenter) <= 1.0f)\{\n    return 1;\n  \}else\{\n    return 0;\n  \}\n\}\nint intersectionsLineUnitSphere(float3 linePoint1, float3 linePoint2, float3 &intersectionPoint1, float3 &intersectionPoint2)\{\n  float3 segmentCenter = projectPointOnLine(linePoint1, linePoint2, float3(0.0f));\n  if(length(segmentCenter) <= 1.0f)\{\n    float segmentHalfLength = sqrt(1-pow(length(segmentCenter), 2.0f));\n    float3 dir = norm(linePoint1 - segmentCenter);\n    intersectionPoint1 = segmentCenter + (dir * segmentHalfLength);\n    intersectionPoint2 = segmentCenter + (-dir * segmentHalfLength);\n    return 1;\n  \}else\{\n    return 0;\n  \}\n\}\nint isIntersectingLineSegmentUnitBox( float3 linePoint1, float3 linePoint2 )\{ \n  // Get line midpoint and extent\n  float3 segmentCenter = (linePoint1 + linePoint2) * 0.5f; \n  float3 segmentHalfLength = (linePoint1 - segmentCenter);\n  float3 segmentExtent = fabs(segmentHalfLength);\n\n  // Use Separating Axis Test\n  // Separation vector from box center to line center is segmentCenter, since the line is in box space\n  if ( fabs( segmentCenter.x ) > 0.5f + segmentExtent.x ) return 0;\n  if ( fabs( segmentCenter.y ) > 0.5f + segmentExtent.y ) return 0;\n  if ( fabs( segmentCenter.z ) > 0.5f + segmentExtent.z ) return 0;\n  // Crossproducts of line and each axis\n  if ( fabs( segmentCenter.y * segmentHalfLength.z - segmentCenter.z * segmentHalfLength.y)  >  (0.5f * segmentExtent.z + 0.5f * segmentExtent.y) ) return 0;\n  if ( fabs( segmentCenter.x * segmentHalfLength.z - segmentCenter.z * segmentHalfLength.x)  >  (0.5f * segmentExtent.z + 0.5f * segmentExtent.x) ) return 0;\n  if ( fabs( segmentCenter.x * segmentHalfLength.y - segmentCenter.y * segmentHalfLength.x)  >  (0.5f * segmentExtent.y + 0.5f * segmentExtent.x) ) return 0;\n  // No separating axis, the line intersects\n  return 1;\n\}\nint intersectionsLineUnitBox(float3 linePoint1, float3 linePoint2, float3 &intersectionPoint1, float3 &intersectionPoint2)\{\n  // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection\n  float tmin, tmax, tymin, tymax, tzmin, tzmax;\n  float3 segmentDirection = linePoint2-linePoint1;\n  float3 segmentDirectionSign = sign(segmentDirection);\n\n  tmin  = ((segmentDirectionSign.x*-0.5) - linePoint1.x) / segmentDirection.x; \n  tmax  = ((segmentDirectionSign.x* 0.5) - linePoint1.x) / segmentDirection.x; \n  tymin = ((segmentDirectionSign.y*-0.5) - linePoint1.y) / segmentDirection.y; \n  tymax = ((segmentDirectionSign.y* 0.5) - linePoint1.y) / segmentDirection.y; \n\n  if ((tmin > tymax) || (tymin > tmax)) \n      return 0; \n  if (tymin > tmin) \n      tmin = tymin; \n  if (tymax < tmax) \n      tmax = tymax;\n\n  tzmin = ((segmentDirectionSign.z*-0.5) - linePoint1.z) / segmentDirection.z; \n  tzmax = ((segmentDirectionSign.z* 0.5) - linePoint1.z) / segmentDirection.z; \n\n  if ((tmin > tzmax) || (tzmin > tmax)) \n      return 0; \n  if (tzmin > tmin) \n      tmin = tzmin; \n  if (tzmax < tmax) \n      tmax = tzmax; \n\n  intersectionPoint1 = linePoint1 + (segmentDirection * tmin);\n  intersectionPoint2 = linePoint1 + (segmentDirection * tmax);\n  return 1;\n\}\nint intersectionsLinePlaneXZ(float3 linePoint1, float3 linePoint2, float3 &intersectionPoint1)\{\n  float3 planeNormal = float3(0,1,0);\n  float3 lineDirection = norm(linePoint2-linePoint1);\n\n  if (dot(planeNormal, lineDirection) == 0.0f) \{\n    // Line  parallel to plane\n    if(linePoint1.y == 0.0f)\{\n      // line is lying on plane\n      return 2;\n    \}else\{\n      if(linePoint1.y > 0.0f)\{\n        // line is parrallel and above plane\n        return 0;\n      \}else\{\n        // line is parrallel and below plane\n        return -1;\n      \}\n    \}\n  \}else\{\n    // Intersection\n    float t = -dot(planeNormal, linePoint1) / dot(planeNormal, lineDirection);\n    intersectionPoint1 = linePoint1 + (lineDirection * t);\n    return 1;\n  \}\n\}\n\n\nfloat fit(float value, float old0, float old1, float new0, float new1)\{\n  return (((value-old0)/old1)*new1)+new0;\n\}\nfloat sphereDensity(float3 point)\{\n  return max(1.0f-(length(point)/1.0f), 0.0f);\n\}\n\nfloat boxDensity(float3 point)\{\n  // Look to optimize\n  point = fabs(point);\n  if(point.x<=0.5f && point.y<=0.5f && point.z<=0.5f)\{\n    float3 q = fabs(point) - float3(0.5f);\n    float sdf = fabs(length(max(q, float3(0,0,0))) + min(max(q.x,max(q.y,q.z)),0.0f));\n    float fullLength = sdf + length(point);\n    return min(max(1.0f-(length(point)/fullLength), 0.0f), 1.0f);\n  \}else\{\n    return 0.0f;\n  \}\n\}\nfloat rampDensity(float3 point)\{\n  return min(max(1.0f-point.y, 0.0f), 1.0f);\n\}\nfloat3 cameraRayDirection(int2 imagePosition, int2 imageSize, float2 angleOfView, const float4x4 &cameraTransformMatrix)\{\n  float3 rayDirection;\n  // Camera angle of view compensation\n  float u = float(imagePosition.x)/(imageSize.x-1);\n  float v = float(imagePosition.y)/(imageSize.y-1);\n  float3 uv_angle = float3(v-0.5f, u-0.5f, 0.0f);\n  uv_angle *= float3(radians(angleOfView.x)*imageSize.y/imageSize.x, -radians(angleOfView.x), 0.0f);\n  // rayDirection\n  float3 rayOrigin = mult(float3(0,0,0), cameraTransformMatrix);\n  rayDirection = float3(0,0,-1);\n  rayDirection = mult(rayDirection, rotate(uv_angle, 0));\n  rayDirection = mult(rayDirection, cameraTransformMatrix);\n  rayDirection = norm(rayDirection-rayOrigin);\n  return rayDirection;\n\}\nfloat normalizeDensity(float density, const float4x4 &shapeTransformMatrix)\{\n  float3 xAxis = mult(float3(1,0,0), shapeTransformMatrix);\n  float3 yAxis = mult(float3(0,1,0), shapeTransformMatrix);\n  float3 zAxis = mult(float3(0,0,1), shapeTransformMatrix);\n  float3 center = mult(float3(0,0,0), shapeTransformMatrix);\n  return density / ((length(xAxis-center)+length(yAxis-center)+length(zAxis-center))/3.0f);\n\}\n\n\nkernel P_vol : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src; // the input image\n  Image<eWrite> dst; // the output image\n\n  param:\n    //Occlusion\n    int occlusionMode; \n    //Shape\n    int shapeType;\n    float4x4 shapeTransformMatrix;\n    //Volume\n    float3 color;\n    float densityMultiplier;\n    float stepSizeUser;\n    int stepMin;\n    int stepMax;\n    int stepsToRefine;\n    int stepRefineAmount;\n    int isDensityNormalized;\n    int isZeroAsInfinity;\n    //Camera\n    float4x4 cameraTransformMatrix;\n    float2 angleOfView;\n    int2 imageSize;\n    //Density Noise\n    int hasDensityNoise;\n    int densityNoiseOctaves;\n    float densityNoiseGain;\n    float densityNoiseTime;\n    float4x4 densityNoiseTransformMatrix;\n    int isdensityNoiseWorldSpace;\n    float densityNoiseFit0;\n    float densityNoiseFit1;\n    float densityNoiseBias;\n    float densityNoiseClamp;\n\n  local:\n    float infinity;\n    float3 rayOrigin;\n    float4x4 shapeTransformMatrixInverted;\n    float4x4 densityNoiseTransformMatrixInverted;\n\n  void define() \{\n    //Occlusion\n    defineParam(occlusionMode, \"occlusionMode\", 0);\n    //Shape\n    defineParam(shapeType, \"shapeType\", 0);\n    defineParam(shapeTransformMatrix, \"shapeTransformMatrix\", float4x4());\n    //Volume\n    defineParam(color, \"color\", float3(1.0f));\n    defineParam(densityMultiplier, \"densityMultiplier\", 1.0f);\n    defineParam(stepSizeUser, \"stepSize\", 0.1f);\n    defineParam(stepMin, \"stepMin\", 100);\n    defineParam(stepMax, \"stepMax\", 100000);\n    defineParam(stepsToRefine, \"stepsToRefine\", 2);\n    defineParam(stepRefineAmount, \"stepRefineAmount\", 10);\n    defineParam(isDensityNormalized, \"isDensityNormalized\", 1);\n    defineParam(isZeroAsInfinity, \"isZeroAsInfinity\", 1);\n    //Camera\n    defineParam(cameraTransformMatrix, \"cameraTransformMatrix\", float4x4());\n    defineParam(angleOfView, \"angleOfView\", float2(0,0));\n    defineParam(imageSize, \"imageSize\", int2(0,0));\n    //DensityNoise\n    defineParam(densityNoiseOctaves, \"densityNoiseOctaves\", 8);\n    defineParam(densityNoiseGain, \"densityNoiseGain\", 0.5f);\n    defineParam(densityNoiseTime, \"densityNoiseTime\", 0.0f);\n    defineParam(densityNoiseTransformMatrix, \"densityNoiseTransformMatrix\", float4x4());\n    defineParam(isdensityNoiseWorldSpace, \"isdensityNoiseWorldSpace\", 1);\n    defineParam(densityNoiseFit0, \"densityNoiseFit0\", 0.0f);\n    defineParam(densityNoiseFit1, \"densityNoiseFit1\", 1.0f);\n  \}\n\n  void init()\{\n    infinity = 1000000000000000000;\n    rayOrigin = mult(float3(0,0,0), cameraTransformMatrix);\n    shapeTransformMatrixInverted = shapeTransformMatrix.invert();\n    densityNoiseTransformMatrixInverted = densityNoiseTransformMatrix.invert();\n  \}\n\n  float sampleDensity(float3 point)\{\n    float shapeDensity = 1, noiseDensity = 1;\n    float3 pointShapeSpace = mult(point, shapeTransformMatrixInverted);\n    // Shape\n    if(shapeType==0)\{\n      shapeDensity = sphereDensity(pointShapeSpace);\n    \}else if(shapeType==1)\{\n      shapeDensity = boxDensity(pointShapeSpace);\n    \}else if(shapeType==2)\{\n      shapeDensity = rampDensity(pointShapeSpace);\n    \}\n    // Noise\n    if(hasDensityNoise)\{\n      float3 pointNoiseSpace;\n      if(isdensityNoiseWorldSpace)\{\n        pointNoiseSpace = point;\n      \}else\{\n        pointNoiseSpace = pointShapeSpace;\n      \}\n      pointNoiseSpace = mult(pointNoiseSpace, densityNoiseTransformMatrixInverted);\n      float noise = octave_noise_4d(densityNoiseOctaves, densityNoiseGain, 1.0f,\n                                           pointNoiseSpace.x, pointNoiseSpace.y,\n                                           pointNoiseSpace.z,densityNoiseTime);\n      //stepDensity = fit(stepDensity, -0.5, 0.5, 0.0f, 1.0f);\n      //stepDensity = fit(stepDensity, densityNoiseFit0, densityNoiseFit1, 0.0f, 1.0f);\n      noiseDensity = max(noise, 0.0f);\n    \}\n    return shapeDensity * noiseDensity;;\n  \}\n  float2 shapeMinMax(float3 linePoint1, float3 linePoint2)\{\n    /*\n    // Need to handle inside shape better\n    */\n    //Bounds optimization\n    float3 linePoint1Inverted = mult(linePoint1, shapeTransformMatrixInverted);\n    float3 linePoint2Inverted = mult(linePoint2, shapeTransformMatrixInverted);\n    float nearDist = 0.0;\n    float farDist = infinity;\n    int isInsideBounds = 1;\n    float3 p1, p2;\n    if(shapeType==0)\{\n      // Sphere\n      isInsideBounds = intersectionsLineUnitSphere(linePoint1Inverted, linePoint2Inverted, p1, p2);\n    if(isInsideBounds)\{\n      //nearDist = length(-linePoint1 + mult(p1, shapeTransformMatrix));\n      //farDist  = length(-linePoint1 + mult(p2, shapeTransformMatrix));\n      nearDist = dot(-linePoint1 + mult(p1, shapeTransformMatrix), norm(linePoint2-linePoint1));\n      nearDist = max(0.0f, nearDist);\n      farDist  = dot(-linePoint1 + mult(p2, shapeTransformMatrix), norm(linePoint2-linePoint1));\n    \}else\{\n      return float2(0);\n    \}\n    \}else if(shapeType==1)\{\n      // Box\n      isInsideBounds = intersectionsLineUnitBox(linePoint1Inverted, linePoint2Inverted, p1, p2);\n    if(isInsideBounds)\{\n      nearDist = dot(-linePoint1 + mult(p1, shapeTransformMatrix), norm(linePoint2-linePoint1));\n      nearDist = max(0.0f, nearDist);\n      farDist  = dot(-linePoint1 + mult(p2, shapeTransformMatrix), norm(linePoint2-linePoint1));\n    \}else\{\n      return float2(0);\n    \}\n    \}else if(shapeType==2)\{\n      // Ramp\n      if((linePoint1Inverted.y-1.0f) <= 0.0f)\{\n        // camera under plane. Volume all around\n      \}else\{\n        isInsideBounds = intersectionsLinePlaneXZ(linePoint1Inverted-float3(0,1,0), linePoint2Inverted-float3(0,1,0), p1);\n        if(isInsideBounds > 0)\{\n          p1 = mult(p1, shapeTransformMatrix);\n          float nearDistSign = sign(dot(norm(p1 - linePoint1), norm(linePoint2-linePoint1)));\n          nearDist = length(-linePoint1 + p1);\n          if(nearDist>60.0f || nearDistSign < 0)\{\n            // too far or behind camera\n            return float2(0);\n          \}\n        \}else\{\n          return float2(0);\n        \}\n      \}\n    \}\n    return float2(nearDist, farDist);\n  \}\n\n  void process(int2 pos) \{\n    //Ray Setup\n    float3 rayDirection = cameraRayDirection(pos, imageSize, angleOfView, cameraTransformMatrix);\n    float hitDist = infinity;\n    float3 hitPosition = rayOrigin + (rayDirection * hitDist);\n\n    //Occlusion setup\n    if(occlusionMode<2)\{\n      float4 rgba = src();\n      if(occlusionMode==0)\{\n        //Depth\n        hitDist = rgba.x;\n        hitPosition = rayOrigin + (rayDirection * hitDist);\n      \}\n      else if(occlusionMode==1)\{\n        //Position\n        hitPosition = float3(rgba.x, rgba.y, rgba.z);\n        hitDist = length(rayOrigin-hitPosition);\n      \}\n      //Fill in \"empty\" values\n      if(isZeroAsInfinity && ((length(hitPosition) <= 1.0f/infinity) || hitDist<=1.0f/infinity))\{\n        hitPosition = rayOrigin + (rayDirection * infinity);\n        hitDist = infinity;\n      \}\n    \}\n\n    \n    //Bounds optimization\n    float2 minMax = shapeMinMax(rayOrigin, hitPosition);\n    float nearDist = minMax.x;\n    float farDist = minMax.y;\n    int isInsideBounds = 1;\n    if(hitDist < nearDist)\{\n      isInsideBounds = 0;\n    \}\n    if(farDist-nearDist<0.00000001)\{\n      isInsideBounds = 0;\n    \}\n    //isInsideBounds = 1;\n    //nearDist = 0.0f;\n    //farDist = infinity;\n\n    //Intersection with shape\n    if(isInsideBounds>0)\{\n      //Init\n      float density = 0.0f;\n      float stepDensity = 0.0f;\n      //float absorption = 0.0f;\n      //float stepAbsorption = 0.0f;\n      int steps = 0;\n      float stepSize = stepSizeUser;\n      float stepSizeDefault = stepSize;\n      float rayDist = nearDist;\n      float minHitDist = min(farDist, hitDist);\n      //Enforce stepMin\n      int predictedSteps = ceil((minHitDist-rayDist)/stepSize);\n      if(predictedSteps<max(1, stepMin))\{\n        stepSize *= float(predictedSteps)/max(1, stepMin);\n        stepSizeDefault = stepSize;\n      \}\n      // Steps in ray direction from near until minimum hit distance. Quit at max steps\n      while(rayDist<=minHitDist && steps<=stepMax)\{\n        float3 stepPosition = rayOrigin + (rayDirection * rayDist);\n\n        // DENSITY\n        stepDensity = sampleDensity(stepPosition);\n        stepDensity = stepDensity * stepSize * densityMultiplier;\n        density += stepDensity;\n\n\n        // STEP\n        //Refine stepSize when close to occlusion\n        if(rayDist > minHitDist-(stepSize*stepsToRefine))\{\n          //Change stepSize only once\n          if(stepSize >= stepSizeDefault)\{\n            stepSize /= float(stepRefineAmount);\n          \}\n        \}\n        //Increment\n        rayDist += stepSize;\n        steps++;\n      \}\n\n      //Normalize density by shape scale\n      if(isDensityNormalized)\{\n        density = normalizeDensity(density, shapeTransformMatrix);\n      \}\n      //Output\n      dst() = float4(density*color.x, density*color.y, density*color.z, density);\n    \}else\{\n      //Out of bounds\n      //dst() = float4(0,0,0.05f,0);\n      dst() = float4(0,0,0,0);\n      return;\n    \}\n  \}\n\};\n"
  rebuild ""
  P_vol_occlusionMode {{parent.occlusionMode}}
  P_vol_shapeType {{parent.shapeType}}
  P_vol_shapeTransformMatrix {
      {{VolumeProcedural2.Shape.world_matrix.0} {VolumeProcedural2.Shape.world_matrix.1} {VolumeProcedural2.Shape.world_matrix.2} {VolumeProcedural2.Shape.world_matrix.3}}
      {{VolumeProcedural2.Shape.world_matrix.4} {VolumeProcedural2.Shape.world_matrix.5} {VolumeProcedural2.Shape.world_matrix.6} {VolumeProcedural2.Shape.world_matrix.7}}
      {{VolumeProcedural2.Shape.world_matrix.8} {VolumeProcedural2.Shape.world_matrix.9} {VolumeProcedural2.Shape.world_matrix.10} {VolumeProcedural2.Shape.world_matrix.11}}
      {{VolumeProcedural2.Shape.world_matrix.12} {VolumeProcedural2.Shape.world_matrix.13} {VolumeProcedural2.Shape.world_matrix.14} {VolumeProcedural2.Shape.world_matrix.15}}
    }
  P_vol_color {{parent.color} {parent.color} {parent.color}}
  P_vol_densityMultiplier {{parent.density}}
  P_vol_stepSize {{parent.stepSize}}
  P_vol_stepMin {{parent.stepMin}}
  P_vol_stepMax {{parent.stepMax}}
  P_vol_stepsToRefine {{parent.stepsToRefine}}
  P_vol_stepRefineAmount {{parent.stepRefineAmount}}
  P_vol_isDensityNormalized {{parent.normalize_density}}
  P_vol_isZeroAsInfinity {{parent.zeroIsInfinity}}
  P_vol_cameraTransformMatrix {
      {{VolumeProcedural2.camera_transform.matrix.0} {VolumeProcedural2.camera_transform.matrix.1} {VolumeProcedural2.camera_transform.matrix.2} {VolumeProcedural2.camera_transform.matrix.3}}
      {{VolumeProcedural2.camera_transform.matrix.4} {VolumeProcedural2.camera_transform.matrix.5} {VolumeProcedural2.camera_transform.matrix.6} {VolumeProcedural2.camera_transform.matrix.7}}
      {{VolumeProcedural2.camera_transform.matrix.8} {VolumeProcedural2.camera_transform.matrix.9} {VolumeProcedural2.camera_transform.matrix.10} {VolumeProcedural2.camera_transform.matrix.11}}
      {{VolumeProcedural2.camera_transform.matrix.12} {VolumeProcedural2.camera_transform.matrix.13} {VolumeProcedural2.camera_transform.matrix.14} {VolumeProcedural2.camera_transform.matrix.15}}
    }
  P_vol_angleOfView {{VolumeProcedural2.AngleOfView.horizontal} {VolumeProcedural2.AngleOfView.vertical}}
  P_vol_imageSize {{width} {height}}
  P_vol_hasDensityNoise {{parent.hasDensityNoise}}
  P_vol_densityNoiseOctaves {{parent.densityNoiseOctaves}}
  P_vol_densityNoiseGain {{parent.densityNoiseGain}}
  P_vol_densityNoiseTime {{parent.densityNoiseTime}}
  P_vol_densityNoiseTransformMatrix {
      {{VolumeProcedural2.DensityNoise.world_matrix.0} {VolumeProcedural2.DensityNoise.world_matrix.1} {VolumeProcedural2.DensityNoise.world_matrix.2} {VolumeProcedural2.DensityNoise.world_matrix.3}}
      {{VolumeProcedural2.DensityNoise.world_matrix.4} {VolumeProcedural2.DensityNoise.world_matrix.5} {VolumeProcedural2.DensityNoise.world_matrix.6} {VolumeProcedural2.DensityNoise.world_matrix.7}}
      {{VolumeProcedural2.DensityNoise.world_matrix.8} {VolumeProcedural2.DensityNoise.world_matrix.9} {VolumeProcedural2.DensityNoise.world_matrix.10} {VolumeProcedural2.DensityNoise.world_matrix.11}}
      {{VolumeProcedural2.DensityNoise.world_matrix.12} {VolumeProcedural2.DensityNoise.world_matrix.13} {VolumeProcedural2.DensityNoise.world_matrix.14} {VolumeProcedural2.DensityNoise.world_matrix.15}}
    }
  P_vol_isdensityNoiseWorldSpace {{parent.isDensityNoiseWorldSpace}}
  rebuild_finalise ""
  name BlinkScript1
  xpos 323
  ypos 402
 }
 Output {
  name Output1
  xpos 323
  ypos 472
 }
end_group
